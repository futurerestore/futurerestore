.\"
.\" Copyright (c) 1998-2017 Apple Inc. All rights reserved.
.\"
.\" This file contains Original Code and/or Modifications of Original Code
.\" as defined in and that are subject to the Apple Public Source License
.\" Version 2.0 (the 'License'). You may not use this file except in
.\" compliance with the License. Please obtain a copy of the License at
.\" http://www.opensource.apple.com/apsl/ and read it before using this
.\" file.
.\" 
.\" The Original Code and all software distributed under the License are
.\" distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
.\" EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
.\" INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
.\" FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
.\" Please see the License for the specific language governing rights and
.\" limitations under the License.
.\"
.Dd 20 June 2017
.Os "macOS"
.Dt DISKUTIL 8
.Pp
.Sh NAME
.Nm diskutil
.Nd modify, verify and repair local disks
.\"
.\"
.\"
.Sh SYNOPSIS
.Nm
.Op Nm quiet
.Ar verb
.Op Ar options
.\"
.\"
.\"
.Sh DESCRIPTION
.Nm
manipulates the structure of local disks.  It provides information about, and allows the administration of,
the partitioning schemes, layouts, and formats of disks. This includes hard disks, solid state disks, optical discs,
APFS volumes, CoreStorage volumes, and AppleRAID sets.
It generally manipulates whole volumes instead of individual files and directories.
.\"
.\"
.\"
.Sh VERBS
Each verb is listed with its description and individual arguments.
.\"
.\" List-Begin-Verbs
.Bl -hang -width "imageinfo"
.\"             -- list --
.It Sy list Op Nm -plist
.Op Nm internal | external
.Op Nm physical | virtual
.Op Ar device
.br
List disks, including internal and external disks, whole disks and partitions,
and various kinds of virtual or offline disks.
.Pp
If no argument is given, then all whole disks and their partitions are listed.
.Pp
You can limit the number of disks shown by specifying filtering arguments such as
.Sy internal
above, and/or a
.Ar device
disk. When limiting by a disk, you can specify either a whole disk, e.g. disk0, or any of its slices,
e.g. disk0s3, but filtering is only done at the whole disk level (disk0s3 is a synonym for disk0 in this case).
.Pp
If
.Sy -plist
is specified, then a property list will be emitted instead of the normal user-readable
output.
.Pp
A script could interpret the results of
.Sy diskutil
.Sy list
.Sy -plist
and use
.Sy diskutil
.Sy info
.Sy -plist
as well as
.Sy diskutil
.Sy listFilesystems
.Sy -plist
for more detailed information.
.Pp
The top-to-bottom appearance of all whole disks is sorted in numerical order by unit (whole disk) number.
However, within each whole disk's "sublist" of partitions, the ordering
indicates actual on-disk location. The first disk item listed represents the partition which is located most near the beginning
of its encompassing whole disk, and so on.
.Pp
When viewed this way, the slice (partition) parts of the
BSD disk identifiers may, in certain circumstances, not appear in numerical order.
This is normal and is likely the result of a recent partition map
editing operation in which volumes were kept mounted.
.Pp
Note that both human-readable and plist output are sorted as described above.
.Pp
See the
.Sy DEVICES
section below for the various forms that the
.Ar device
specification may take for this and all of the other
.Nm
verbs.
.\"
.\"             -- info --
.It Sy info | information
.Op Sy -plist
.Ar device |
.Sy -all
.br
Get detailed information about a specific whole disk or partition.
If
.Sy -plist
is specified, then a property list instead of the normal user-readable output will be emitted.
If
.Sy -all
is specified, then all disks (whole disks and their partitions) are processed.
.\"
.\"             -- activity --
.It Sy activity
.br
Continuously display system-wide disk manipulation activity as reported by the Disk
Arbitration framework until interrupted with a signal (e.g. by typing
Control-C).
.Pp
This can be useful to watch system-wide activity of disks coming on-line or being ejected,
volumes on disks being mounted or unmounted, volumes being renamed, etc.
However, this output must never be parsed; programs should become Disk Arbitration clients
instead.
.Pp
For debugging
information, such as the monitoring of applications dissenting (attempting to deny) activities
for disks
for which they have registered an interest, you must use the logging features of the
.Sy diskarbitrationd
daemon. Programs needing this information must become Disk Arbitration clients.
.\"
.\"             -- listFilesystems --
.It Sy listFilesystems
.Op Nm -plist
.br
Show the file system personalities available for formatting in
.Sy diskutil
when using the erasing and partitioning verbs.
This is a subset of the complete set of
personalities exported by the various file system bundles that may be installed in the system.
Also shown are some shortcut aliases for common personalities.
See the
.Sy FORMAT
section below for more details.
If
.Sy -plist
is specified, then a property list instead of the normal user-readable output will be emitted.
.\"
.\"             -- unmount --
.It Sy unmount | umount
.Op Nm force 
.Ar device
.br
Unmount a single volume.
.Sy Force
will force-unmount the volume (less kind to any open files; see also
.Sy umount
(8)).
.\"
.\"             -- unmountDisk --
.It Sy unmountDisk | umountDisk
.Op Nm force 
.Ar device
.br
Given a disk containing a partition map, unmount all of its volumes. That is,
unmounts are attempted for the map's partitions containing file system volumes, as well as
for "virtual" volumes exported by storage systems which import data
from the map's partitions.
Storage systems supported include APFS, AppleRAID, and CoreStorage.
.Pp
.Sy Force
will force-unmount the volumes (less kind to any open files; see also
.Sy umount
(8)).
.Pp
You should specify a whole disk, but all volumes of the whole disk are attempted to be unmounted even if you specify a partition.
.\"
.\"             -- eject --
.It Sy eject Ar device
.br
Eject a disk.  Media will become offline for the purposes of being a data store for file systems or
being a member of constructs such as software RAID or direct data.  Additionally, removable media will
become eligible for safe manual removal; automatically-removable media will begin its
physical (motorized) eject sequence.
.\"
.\"             -- mount --
.It Sy mount Op Nm readOnly
.Op Nm -mountPoint Ar path
.Ar device
.br
Mount a single volume.
If
.Sy readOnly
is specified, then the file system is mounted read-only, even if the
volume's underlying file system and/or device and/or media
supports writing; even the super-user may not write to it; this is the same as the
.Sy rdonly
option to
.Sy mount
(8).
If a
.Sy -mountPoint
is specified, then that path, rather than the standard path of /Volumes/VolumeName, will
be used as the view into the volume file content; a directory at that path must already exist.
.\"
.\"             -- mountDisk --
.It Sy mountDisk Ar device
.br
Mount all mountable and UI-browsable volumes on the given partition map; that is,
a mount is attempted on the directly-mountable volume, if any, on each of the whole disk's
partitions. However, "virtual" volumes, such as those are implied by e.g. Core Storage
Physical Volumes, AppleRAID Members, etc., are not handled.
You should specify a whole disk, but all volumes of the whole disk are attempted to be mounted even if you specify a partition.
.\"
.\"             -- rename --
.It Sy rename | renameVolume Ar device Ar name
.br
Rename a volume.
Volume names are subject to file system-specific alphabet and length restrictions.
.\"
.\"             -- enableJournal --
.It Sy enableJournal Ar device
.br
Enable journaling on an HFS+ volume.  This works whether or not the volume is currently mounted
(the volume is temporarily mounted if necessary).
Ownership of the affected disk is required.
.\"
.\"             -- disableJournal --
.It Sy disableJournal
.Op Nm force
.Ar device
.br
Disable journaling on an HFS+ volume.  This normally works whether or not the volume is currently
mounted (the volume is temporarily mounted if necessary).  If the
.Sy force
option is specified, then journaling is disabled directly on disk; in this case, the volume
must not be mounted.
Ownership of the affected disk is required.
.\"
.\"             -- moveJournal external --
.It Sy moveJournal
.Sy external
.Ar journalDevice
.Ar device
.br
Create a 512MB Apple_Journal partition using the
.Ar journalDevice
partition to serve as a journal for the volume
.Ar device.
For best results,
.Ar journalDevice
should be a partition on a different whole-disk than the volume itself.
.Pp
The journal for
.Ar device
will be moved externally onto the newly created Apple_Journal partition.
.Pp
Since the
.Ar journalDevice
you specify will invariably be larger than 512MB, a new HFS+ partition will be created
following the Apple_Journal partition to fill the remaining space.
.Pp
Moving the journal works whether or not the volume is mounted, provided
journaling is enabled on that volume. No errors are currently supported to flag attempts to
move journals on volumes that do not have journaling enabled.
If you have multiple volumes for which you want external journals, each must have its own
external Apple_Journal partition.
Ownership of the affected disks is required.
.\"
.\"             -- moveJournal internal --
.It Sy moveJournal
.Sy internal
.Ar device
.br
Move the journal for
.Ar device
back locally (onto that same device).
Ownership of the affected disk is required.
.\"
.\"             -- enableOwnership --
.It Sy enableOwnership Ar device
.br
Enable ownership of a volume.  The on-root-disk Volume Database at /var/db/volinfo.database is manipulated such that
the User and Group ID settings of files, directories, and links (file system objects, or "FSOs") on the target volume
are taken into account.
.Pp
This setting for a particular volume is persistent across ejects and injects of that volume as seen
by the current OS, even across reboots of that OS, because of the entries in this OS's Volume Database.  Note thus
that the setting is not kept on the target disk, nor is it in-memory.
.Pp
For some locations of devices (e.g. internal hard disks), consideration of ownership settings on FSOs is the default.
For others (e.g. plug-in USB disks), it is not.
.Pp
When ownership is disabled, Owner and Group ID settings on FSOs appear to the user and programs as the current user and group instead
of their actual on-disk settings, in order to
make it easy to use a plug-in disk of which the user has physical possession.
.Pp
When ownership is enabled, the Owner and Group ID settings that exist on the disk are taken into account for determining
access, and exact settings are written to the disk as FSOs are created.  A common reason for
having to enable ownership is when a disk is to contain FSOs whose User and Group ID settings, and thus permissions
behavior overall, is critically important, such as when the plug-in disk contains system files to be changed or added to.
.Pp
See also the
.Xr vsdbutil 8
command.  Running as root is required.
.\"
.\"             -- disableOwnership --
.It Sy disableOwnership Ar device
.br
Disable ownership of a volume.  See
.Sy enableOwnership
above.
Running as root is required.
.\"
.\"             -- verifyVolume --
.It Sy verifyVolume Ar device
.br
Verify the file system data structures of a volume.  The appropriate fsck program is executed and
the volume is left mounted or unmounted as it was before the command.
Ownership of the disk to be verified is required.
.\"
.\"             -- repairVolume --
.It Sy repairVolume Ar device
.br
Repair the file system data structures of a volume.  The appropriate fsck program is executed and
the volume is left mounted or unmounted as it was before the command.
Ownership of the affected disk is required.
.\"
.\"             -- verifyDisk --
.It Sy verifyDisk Ar device
.br
Verify the partition map layout of a whole disk intended for booting or data use on a Macintosh.
The checks further include, but are not limited to, the integrity of the EFI System Partition,
the integrity of any Core Storage Physical Volume partitions,
and provisioning of space for boot loaders.
Ownership of the disk to be verified is required; it must be a whole disk and must have a partition map.
.\"
.\"             -- repairDisk --
.It Sy repairDisk Ar device
.br
Repair the partition map layout of a whole disk intended for booting or data use on a Macintosh.
The repairs further include, but are not limited to, the repair or creation of an EFI System Partition,
the integrity of any Core Storage Physical Volume partitions,
and the provisioning of space for boot loaders.
Ownership of the affected disk is required; it must be a whole disk and must have a partition map.
.\"
.\"             -- eraseDisk --
.It Sy eraseDisk Ar format Ar name 
.Op Nm APM[Format] | MBR[Format] | GPT[Format]
.Ar device
.br
Erase an existing disk, removing all volumes and writing out a new partitioning scheme
containing one new empty file system volume.  If the partitioning scheme is not
specified, then an appropriate one for the current machine is chosen.
.Ar Format
is discussed below in the section for the
.Sy partitionDisk
verb.
Ownership of the affected disk is required.
.\"
.\"             -- eraseVolume --
.It Sy eraseVolume 
.Ar format
.Ar name
.Ar device
.br
Write out a new empty file system volume (erasing any current file system volume) on an existing partition.
The partition remains but its data is lost.
.Ar Format
is discussed below in the section for the
.Sy partitionDisk
verb.
.Pp
If you specify
.Sy Free Space
for
.Ar format ,
the partition itself is deleted (removed entirely) from the partition map instead of merely being erased.
Ownership of the affected disk is required.
.\"
.\"             -- reformat --
.It Sy reformat Ar device
.br
Erase an existing volume by writing out a new empty file system of the same personality (type) and with the
same volume name.
Ownership of the affected disk is required.
.\"
.\"             -- eraseOptical --
.It Sy eraseOptical 
.Op Nm quick 
.Ar device
.br
Erase optical media (CD/RW, DVD/RW, etc.).
.Sy Quick
specifies whether the disc recording system software should do a full erase or a quick erase.
Ownership of the affected disk is required.
.\"
.\"             -- zeroDisk --
.It Sy zeroDisk Op Nm force
.Ar device
.br
Erase a device, writing zeros to the media.  The device can be a whole-disk or a partition.
In either case, in order to be useful again, zeroed whole-disks
will need to be (re)partitioned, or
zeroed partitions will need to be (re)formatted with a file system, e.g. by using the
.Sy partitionDisk,
.Sy eraseDisk,
or
.Sy eraseVolume
verbs.
If you desire a more sophisticated erase algorithm or if you need
to erase only free space not in use for files, use the
.Sy secureErase
verb.
The
.Sy force
parameter causes best-effort, non-error-terminating, forced unmounts and shared-mode writes to be attempted;
however, this is still no guarantee against drivers which claim the disk exclusively. In such cases, you
may have to first unmount all overlying logical volumes (e.g. CoreStorage or AppleRAID). If a disk is partially
damaged in just a certain unlucky way, you might even have to un-install a kext or erase the disk elsewhere.
Ownership of the affected disk is required.
.\"
.\"             -- randomDisk --
.It Sy randomDisk 
.Op Ar times
.Ar device
.br
Erase a whole disk, writing random data to the media.
.Ar Times
is the optional (defaults to 1) number of times to write random information.
The device can be a whole-disk or a partition.
In either case, in order to be useful again, randomized whole-disks
will need to be (re)partitioned, or
randomized partitions will need to be (re)formatted with a file system, e.g. by using the
.Sy partitionDisk,
.Sy eraseDisk,
or
.Sy eraseVolume
verbs.
If you desire a more sophisticated erase algorithm or if you need
to erase only free space not in use for files, use the
.Sy secureErase
verb.
Ownership of the affected disk is required.
.\"
.\"             -- secureErase --
.It Sy secureErase
.Op Nm freespace
.Ar level
.Ar device
.br
Erase, using a "secure" (but see the NOTE below) method,
either a whole-disk (including all of its partitions if partitioned), or,
only the free space (not in use for files) on a currently-mounted volume.
Secure erasing makes it harder to recover data using "file recovery" software.
.Pp
Erasing a whole-disk will leave it useless until it is partitioned again.
Erasing freespace on a volume will leave your files intact,
indeed, from an end-user perspective, it will appear unchanged,
with the exception that it will have attempted to make it impossible to recover deleted files.
.Pp
If you need to erase all contents of a partition but not its hosting
whole-disk, use the
.Sy zeroDisk
or
.Sy randomDisk
verbs.
Ownership of the affected disk is required.
.Pp
.Ar Level
should be one of the following:
.\" List-Begin-SecureEraseOptions
.Bl -bullet -offset indent
.It
0 - Single-pass zero-fill erase.
.It
1 - Single-pass random-fill erase.
.It
2 - US DoD 7-pass secure erase.
.It
3 - Gutmann algorithm 35-pass secure erase.
.It
4 - US DoE algorithm 3-pass secure erase.
.\" List-End-SecureEraseOptions
.El
.Pp
NOTE: This kind of secure erase is no longer considered safe because modern devices have wear-leveling,
block-sparing, and possibly-persistent cache hardware. The modern solution for quickly and securely
erasing your data is strong encryption, with which mere destruction of the key more or
less instantly renders your data irretrievable in practical terms.
.\"
.\"             -- partitionDisk --
.It Sy partitionDisk Ar device
.Op Ar numberOfPartitions
.Op Nm APM[Format] | MBR[Format] | GPT[Format]
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
.br
.Pp
(re)Partition a disk, removing all volumes.  All volumes on this disk will be destroyed.
The
.Ar device
parameter specifies which whole disk is to be partitioned.
The optional
.Ar numberOfPartitions
parameter specifies the number of partitions to create; if given then the number of
parameter triplets (see below) is expected to match; else, the number of triplets alone
given will determine the number of partitions created.
.Pp
The optional partitioning scheme parameter forces a particular partitioning scheme; if not specified, a
suitable default is chosen.  They are:
.\" List-Begin-PartitioningSchemes
.Bl -bullet -offset indent
.It
.Sy APM[Format]
specifies that an Apple Partition Map scheme should be used.
This is the traditional Apple partitioning scheme
used to start up a PowerPC-based Macintosh computer, to use the disk as a non-startup disk with any Mac,
or to create a multiplatform compatible startup disk.
.It
.Sy MBR[Format]
specifies that a Master Boot Record scheme should be used.
This is the DOS/Windows-compatible partitioning scheme.
.It
.Sy GPT[Format]
specifies that a GUID Partitioning Table scheme should be used.
This is the partitioning scheme
used to start up an Intel-based Macintosh computer.
.\" List-End-PartitioningSchemes
.El
.br
.Pp
For each partition, a triplet of the desired file system format, volume name, and size must be specified.
Several other
.Sy diskutil
verbs allow these triplets as well (and for them, the
.Ar numberOfPartitions
parameter is also optional).  The triplets must be as follows:
.\" List-Begin-PartitionRequestTriplets
.Bl -bullet -offset indent
.It
.Ar Format
names are of the form jhfs+, HFS+, MS-DOS, etc.; a list of formattable file systems (more precisely, specific file system personalities exported by
the installed file system bundles)
and common aliases is available from the
.Sy listFilesystems
verb.
.Pp
.Ar Format
guides
.Sy diskutil
both in what partition type to set for the partitions (slices) as well as what file system structures to initialize therein,
using the file system bundle's plist's FormatExecutable setting which usually points to the appropriate formatter program such as
.Xr newfs_hfs 8 .
.Pp
You can specify a
.Ar format
of
.Sy Free Space
to skip an area of the disk.
.Pp
You can specify the partition type manually and directly with a
.Ar format
of %<human-readable partition type>%
such as
.Sy %Apple_HFS%
or %<GPT partition type UUID constant>%
such as
.Sy %48465300-0000-11AA-AA11-00306543ECAC%;
these imply a
.Ar name
of
.Sy %noformat%
(below).  Human-readable types must be known to the system but UUID types (GPT scheme only) can be arbitrary.
.It
.Ar Names
are the initial volume names; they must conform to file system specific restrictions.
.Pp
If a name of
.Sy %noformat%
is specified, then the partition is left blank such that the partition space is carved out, the partition type is set
according to the file system format name or explicit type, the partition space is partially erased ("wiped"),
but a file system structure
is not initialized with any file system's formatter program (e.g.
.Ns Xr newfs_hfs 8 ; this is useful for setting up partitions that will
contain user-defined (not necessarily file system) data.
.Pp
For a triplet whose
.Ar format
is
.Sy Free Space
or a directly-specified partition type, its
.Ar name
is ignored but a dummy name must nevertheless be present.
.It
.Ar Sizes
are floating point numbers followed by a letter or percent sign as described in the
.Sy SIZES
section at the end of this page (e.g. 165536000, 55.3T, 678M, 75%, R).
.\" List-End-PartitionRequestTriplets
.El
.Pp
In addition to explicitly-requested partitions, space (gaps) might be allocated to satisfy certain filesystems'
position and length alignment requirements; space might be allocated for possible future booter partition
insertion; and indeed, actual booter partitions might be implicitly created.
.Pp
In particular, there is a rule that unrecognized partitions 1GiB or larger automatically acquire booters.
Thus, if you create an arbitrary partition with e.g.
.Sy diskutil partitionDisk disk0 gpt %11112222-1111-2222-1111-111122221111% %noformat% 3gib jhfs+ Untitled r ,
then a booter partition will also be created. You can always delete that booter with
.Sy diskutil eraseVolume \&"Free Space\&" dummy disk0s3 .
.Pp
The last partition is usually automatically lengthened to the end of the partition map (disk).
You can specify an exact size for your last partition by specifying it as the penultimate
triplet and specifying an additional (last) triplet as
.Sy Free Space .
Or you can use the
.Sy R
(remainder) size specifier for one of your middle partitions while specifying an exact size for your last partition.
.Pp
Ownership of the affected disk is required.
.\"
.\"             -- resizeVolume --
.It Sy resizeVolume Ar device [
.Sy limits
|
.Sy mapsize
|
.Sy R
|
.Ar size 
.Op Ar numberOfPartitions
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
]
.br
.Pp
Non-destructively resize a volume (partition); you may increase or decrease its size. Alternatively, takes no action and prints some info.
.Pp
A
.Ar size
of
.Sy limits
takes no action, but instead
will print the range of valid values for the target partition, taking into account current file system and partition map conditions
such as files in use and other (immovable) partitions following the target.
.Pp
A
.Ar size
of
.Sy mapsize
takes no action, but instead
will print the size of the encompassing whole-disk device, as well as the size of the entire partition map (all partitions less map
overhead). The whole-disk device might be
larger than the partition map if the whole-disk device has grown since the partition map was created. Growing a whole-disk device is
possible with certain enterprise disk (RAID) systems.
.Pp
You can grow a volume (partition) (back) to its maximum size possible, provided no new partitions have been created that are in the way, by specifying
.Sy R
for the new volume size. You should use
.Sy R
instead of attempting an absolute value such as
.Sy 100%
because the latter cannot count partition map overhead.
.Pp
When decreasing the size, new partitions may optionally be created to fill the newly-freed space.
To do this, specify the
.Ar numberOfPartitions,
.Ar format,
.Ar name,
and
.Ar size
parameters in the same manner as the triplet description for the
.Sy partitionDisk
verb.
.Pp
Resizing a volume that is currently set as the computer's startup disk will invalidate that setting; use the 
.Sy Startup
.Sy Disk
System Preferences panel or
.Sy bless
(8) to reset the resized volume as the startup disk.
.Pp
.Ar Device
refers to a volume; the volume's file system must be journaled HFS+.
Valid
.Sy sizes
are a number followed by a capital letter multiplier or percent sign suffix as described in the
.Sy SIZES
section at the end of this page (e.g. 1.5T, 128M, 50%).
Ownership of the affected disk is required.
.\"
.\"             -- splitpartition --
.It Sy splitPartition Ar device
.Op Ar numberOfPartitions 
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
.br
.Pp
Destructively split a volume into multiple partitions.  You must supply a list of new partitions to create
in the space of the old partition; specify these with the
.Ar numberOfPartitions,
.Ar format,
.Ar name,
and
.Ar size
parameters in the same manner as the triplet description for the
.Sy partitionDisk
verb.
.Pp
For one of your triplets, you can optionally specify the
.Sy R
meta-size in lieu of a constant number value for the
.Ar size
parameter: the substituted value will be exactly the amount of space necessary to complete the
re-filling of the original partition with all of your triplets.
.Pp
.Ar Device
refers to a volume.
Ownership of the affected disk is required.
.\"
.\"             -- mergepartitions --
.It Sy mergePartitions
.Op Nm force
.Ar format Ar name Ar fromDevice Ar toDevice
.br
Merge two or more partitions on a disk.  All data on merged partitions other than the first will be lost.
Data on the first partition will be lost as well if the
.Sy force
argument is given.
.Pp
If
.Sy force
is not given, and the first partition has a resizable file system
(e.g. JHFS+), the file system will be preserved and grown in a data-preserving manner; your
.Ar format
and
.Ar name
parameters are ignored in this case. If
.Sy force
is not given, and the first partition is not resizable, you are prompted if you want to format.
You will also be prompted to format if the first partition has an (HFS) Allocation Block Size
which is too small to support the required growth of the first partition; see the
.Sy -b
option for
.Sy newfs_hfs
(8).
.Pp
If
.Sy force
is given, the final resulting partition is always (re)formatted. You should do this if you wish to (re)format to a new file system type.
You will be prompted to confirm.
.Pp
.Ar Format
and
.Ar name
must always be given, but they have an effect only when
.Sy force
is given.
.Pp
Merged partitions are required to be ordered sequentially on disk (see
.Sy diskutil
.Sy list
for the actual on-disk ordering).
All partitions in the range, except for the first one, must be unmountable.
Ownership of the affected disk is required.
.\"
.\"             -- APFS --
.It Sy APFS | ap Ar apfsVerb Op ...
.br
Apple APFS is a system of virtual volumes.
APFS verbs can be used to create, manipulate and destroy APFS Containers and their APFS Volumes.
Apple APFS defines these types of objects:
.\" List-Begin-APFSObjects
.Bl -bullet -offset indent
.It
Container - An APFS Container imports one or more
APFS Physical Store disks and exports zero or more APFS Volume disks.
Zero or more APFS Containers can exist in (might be attached to) the system at any one time.
.Pp
While attached, the "handle" by which an APFS Container is identified is by its APFS
.Sy Container Reference
disk (device). You should treat this as an opaque reference token.
.Pp
The
.Sy Container Reference
disk is a synthesized whole-disk which is exported by APFS for identification
purposes only; it has no storage. It is associated with the AppleAPFSContainerScheme node in the
IO Registry. While APFS Volume device identifiers appear to be of a related form,
you should never use the Container Reference as a basis to create device identifiers yourself;
use the listing verbs with their plist options instead.
.It
Physical Store - An APFS Physical Store is a disk which is imported into (that is, which backs,
indeed defines) an APFS Container. An APFS Container can import more than one Physical Store,
e.g. for Fusion-style Containers.
.Pp
An APFS Physical Store disk is not necessarily a disk from a partition map; it could be
e.g. an AppleRAID Set disk. Therefore, you must never assume that
an APFS Physical Store's disk identifier is a 2-part form such as disk0s2.
.It
Volume - An APFS Volume is an [un]mountable file system volume which is exported from an APFS Container.
Zero or more APFS Volumes may be exported out of an APFS Container.
.Pp
APFS Volumes have no specified "size" (capacity). Instead, all APFS Volumes consume capacity out of
the remaining free space of their parent APFS Container, consuming or returning such capacity as
user file data is added or deleted. Note that this means that all Volumes within a
Container compete for the Container's remaining capacity. However, you can manage Volume allocation
with the optional
.Sy reserve
and
.Sy quota
size values.
.Pp
The optional
.Sy reserve
size requests an assured minimum capacity for an APFS Volume. If successfully created, the Volume is guaranteed
to be able to store at least this many bytes of user file data. Note that beyond this, the Volume might
be able to store even more until constrained by reaching zero free space in its parent Container
or by reaching a quota, if any. You can use a
.Sy reserve
to prevent running out of capacity due to competition from other Volumes or from a Container shrink attempt.
.Pp
The optional
.Sy quota
size applies a maximum capacity to an APFS Volume, placing a limit on the number of bytes of user file data
which can be stored on the Volume. Note that you might not be able to reach this limit if its parent Container
becomes full first. You can use a
.Sy quota
to enforce accounting or to manage against "unfair" premature filling-up of
the parent Container due solely to this Volume at the expense of sibling Volumes.
.Pp
Efficient file copy cloning (copy-on-write) is supported (see
.Sy copyfile
(3)'s COPYFILE_CLONE).
.Pp
Optional file-level encryption is supported.
.Pp
The format of an APFS Volume's device identifier is that of a slice disk of a special whole-disk;
both disks are synthesized by APFS. The "whole" identifier number (a positive possibly-multi-digit integer)
is arbitrary, and the "slice" numbers (positive possibly-multi-digit integers) count up from 1 with each
new Volume. Deleting Volumes may cause gaps in the numbering until the next eject/attach cycle.
This form appears the same as a partition (map) scheme and partitions, but it is completely unrelated.
For example: If "disk3s2" is a Physical Store defining a Container, then "disk5s1", "disk5s2", and "disk5s3"
might be the Container's Volumes; "disk5" exists but is never used directly.
.Pp
Although it has a device node, an APFS Volume's data may only be accessed through its files;
you cannot open an APFS Volume device node to "directly" access its on-disk bytes.
.It
Snapshot - An APFS Volume can have zero or more associated APFS Snapshots.
An APFS Snapshot appears as a read-only copy of its parent APFS Volume at a frozen moment in time.
Snapshots are neither listed nor discoverable when their Volume is not mounted.
.\" List-End-APFSObjects
.El
.Pp
APFS itself has no provision for backing up your data.
Backups should be always be performed on a regular basis and before modifying any APFS Container using these commands.
.Pp
The following is a list of
.Sy APFS
sub-verbs with their descriptions and individual arguments.
.br
.\"
.\" List-Begin-APFSVerbs
.Bl -hang -width "imageinfo"
.\"
.\"             -- APFS > list --
.It Sy list Op Nm -plist
.Op Ar containerReferenceDevice
.br
Display APFS objects as a tree. AFPS Container(s) are shown with
their imported Physical Store(s) and exported Volume(s).
.Pp
All currently-attached APFS Containers in the system are listed unless you specify a
.Ar containerReferenceDevice ,
which limits the output to that specific APFS Container family.
.Pp
If
.Sy -plist
is specified, then a property list will be emitted
instead of the normal user-readable output.
.\"
.\"             -- APFS > convert  --
.It Sy convert Ar device
.Op Nm -dryrun
.br
Non-destructively convert an HFS volume to an APFS Container with a single
APFS Volume. The APFS Container can then be manipulated (e.g. adding and deleting APFS Volumes) as usual.
The source HFS volume can be located on a partition or on a CoreStorage logical volume (LV);
in the latter case, the CoreStorage logical volume group (LVG) is dismantled.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > create  --
.It Sy create Ar device
.Op Ar device
.Ar name
.br
Convenience verb which creates an empty APFS Container and then adds one APFS Volume with the given name.
The APFS Volume will have default attributes such as no encryption, no capacity reserve nor quota, etc.
This is a combination of the
.Sy diskutil apfs createContainer
and
.Sy diskutil apfs addVolume
verbs.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > createContainer --
.It Sy createContainer
.Op Nm -main
.Ar device
.Op Nm -secondary
.Op Ar device
.br
Create an empty APFS Container.
The device(s) specified become APFS Physical Stores.
.Pp
If you specify more than one device, a Fusion Container is created, with the performance roles
assigned automatically (preferred) unless you use the
.Nm -main
and
.Nm -secondary
options, in which case, the secondary disk is assumed by APFS's performance algorithms to be on "slower" hardware.
The secondary disk is usually not solid solid state, is usually larger, and is used to store associated "auxiliary"
data such as any Windows partition(s) for Boot Camp Assistant.
.Pp
You may then add APFS Volumes with the
.Sy diskutil apfs addVolume
verb.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > deleteContainer  --
.It Sy deleteContainer
.Ar containerReferenceDevice | physicalStoreDevice
.Op Ar name
.br
Destroy an existing APFS Container, including all of its APFS Volumes.
The APFS Volumes are unmounted first; this process may not succeed if one or more is busy. If this
happens, the operation is aborted and everything is left intact.
Otherwise, all APFS Volumes are deleted as well as its APFS Container, and
the APFS Container's former Physical Store disks will be reformatted as HFS; data on all
APFS Volumes will be lost.
.Pp
You can optionally specify a new
.Ar name ,
or else "Untitled" will be chosen.
If there were multiple Physical Stores, a space and a number suffix is added for each.
.Pp
Specifying an APFS Physical Store activates an alternate last-resort mode which tries to reclaim your disk(s)
even though they may be unusable due to being damaged yet un-deletable due to being busy.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > resizeContainer  --
.It Sy resizeContainer
.Ar containerReferenceDevice
|
.Ar physicalStoreDevice
.Ar size
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
.br
Resize an existing APFS Container by specifying either an APFS Container Reference (preferred) or an APFS Physical Store partition,
and a proposed new size. The operation is live, non-destructive, and does not mount or unmount any APFS Volumes.
.Pp
If you specify a Container Reference and that Container imports more than one Physical Store (e.g. Fusion),
the appropriate Physical Store will be chosen automatically.
.Pp
Shrinks are constrained by the amount of data usage by all APFS Volumes on the APFS Container.
Grows are constrained by the amount of partition map free space trailing the targeted Physical Store partition.
.Pp
When shrinking, new partitions may optionally be created to fill the newly-freed space.
To do this, specify the
.Ar format,
.Ar name,
and
.Ar size
parameters in the same manner as the triplet description for the
.Sy partitionDisk
verb.
.Pp
You can specify a
.Ar size
of zero
.Sy (0)
to grow the targeted APFS Physical Store such that
all remaining space is filled to the next partition or the end of the partition map.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > addVolume --
.It Sy addVolume
.Ar containerReferenceDevice
.Ar filesystem
.Ar name
.Op Nm -passprompt
|
.Op Nm -passphrase Ar passphrase
|
.Op Nm -stdinpassphrase
.Op Nm -passphraseHint Ar passphraseHint
.Op Nm -reserve Ar reserve
.Op Nm -quota Ar quota
.Op Nm -role Ar roles
.Op Nm -nomount
.Op Nm -mountpoint Ar mountpoint
.br
Add a new APFS Volume to an existing APFS Container. Files can then be stored on this newly-created APFS Volume.
.Pp
The
.Ar filesystem
parameter sets the permanent APFS personality for this new APFS Volume; you should specify
.Sy APFS
or
.Sy Case-sensitive APFS.
.Pp
The new APFS Volume will be unencrypted unless you specify one of the passphrase options, in which case the
volume will be encrypted from the beginning of its existence (as opposed to having encryption applied later);
the user which is added will be the "Disk User".
The optional
.Ar passphraseHint
is a user-defined string that can be displayed even while an encrypted APFS Volume is locked.
.Pp
APFS Volumes have no fixed size; they allocate backing store on an as-needed basis.
You can specify the
.Ar reserve
parameter to guarantee a minimum amount of space for your volume; at least that many bytes will be available for file data.
You can also specify the
.Ar quota
parameter to limit your volume's file usage to a maximum amount; no more than that many bytes will be available for file data,
even if there is otherwise enough space in the parent APFS Container.
You can specify both
.Ar reserve
and
.Ar quota
simultaneously; however, the reserve is not allowed to be larger than the quota.
.Pp
APFS Volumes can carry certain metadata hint flags; you can supply the
.Ar role
parameter with any combination of one or more of the characters
.Sy BRV,
or
.Sy 0
as a no-op for scripting convenience.
.Pp
The new APFS Volume is explicitly mounted after creation; you can specify
.Sy -nomount
to leave it unmounted or supply a
.Ar mountpoint
for a "custom" mountpoint path, in which case the directory must already exist
and you must delete the directory yourself when you unmount.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > deleteVolume --
.It Sy deleteVolume
.Ar volumeDevice
.br
Remove the given APFS Volume from its APFS Container. All of the Volume's data will be lost.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > eraseVolume --
.It Sy eraseVolume
.Ar volumeDevice
.Nm -name
.Ar newName
.Op Nm -passprompt
|
.Op Nm -passphrase Ar passphrase
|
.Op Nm -stdinpassphrase
.Op Nm -passphraseHint Ar passphraseHint
.br
Erase the contents of an existing APFS Volume; all of its data will be lost.
Unlike
.Sy diskutil apfs deleteVolume ,
the APFS Volume is not removed from its APFS Container.
.Pp
The "new" APFS Volume will inherit the APFS file system type (Case-sensitive or not) but will not inherit attributes
such as name, reserve, quota, or encryption status.
.Pp
The "new" APFS Volume be unencrypted, unless you supply
passphrase options in the same manner as
.Sy diskutil apfs addVolume
in which
case it will be encrypted and initially accessible by the "Disk User".
.Pp
If you need more control, you should delete and (re-)add the Volume instead.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > changeVolumeRole --
.It Sy changeVolumeRole | chrole
.Ar volumeDevice
.Ar roles
.br
Change the role metadata flag bits of an existing APFS Volume.
.Pp
The
.Ar roles
should be any combination of one or more of the characters
.Sy brvBRV
in much the same manner as
.Sy diskutil
.Sy apfs
.Sy addVolume
above,
in which unspecified flags are left alone, use of lower-case causes flags to be cleared, and use
of upper-case causes flags to be set.
Alternatively,
.Sy clear
will remove all flags, or
.Sy 0
can be used as a no-op for scripting convenience.
You should not make any assumptions about the usage or legal combinations of role bits.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > unlockVolume --
.It Sy unlockVolume | unlock
.Ar volumeDevice
.Op Nm -user Nm disk | Ar cryptoUserUUID
.Op Nm -passphrase Ar passphrase
|
.Op Nm -stdinpassphrase
.Op Nm -nomount | -mountpoint Ar mountpoint
.Op Nm -verify
.br
Unlock and mount an encrypted and locked APFS Volume or verify a passphrase.
.Pp
If you do not supply
the
.Sy -user
option, then all cryptographic users on that APFS Volume are searched for a match; if you supply
.Sy disk
then the Disk UUID (which equals the APFS Volume UUID) is assumed; if you supply
a UUID then that specific user is assumed.
.Pp
You will be prompted interactively for a passphrase
unless you specify a passphrase parameter with
.Sy -passphrase
or pipe your passphrase into stdin and use
.Sy -stdinpassphrase.
.Pp
You can skip the explicit mounting step or specify a "custom" mountpoint with the
.Sy -nomount
or
.Sy -mountpoint
options. If you specify your own mountpoint path, it must exist and you must have write privileges on it.
.Pp
Specifying
.Sy -verify
will test passphrase correctness without affecting the locked or unlocked state.
.Pp
To re-lock the volume, unmount it, e.g. with
.Sy diskutil
.Sy unmount
or
.Sy diskutil
.Sy apfs
.Sy lockVolume.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > lockVolume --
.It Sy lockVolume | lock
.Ar volumeDevice
.br
Unmount and lock an encrypted unlocked APFS Volume. This is mostly a synonym for
.Sy diskutil
.Sy unmount.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > listCryptoUsers --
.It Sy listCryptoUsers | listUsers
.Op Nm -plist
.Ar volumeDevice
.br
Show all cryptographic users (by their Cryptographic User UUID) that are associated with the given APFS Volume.
.Pp
If
.Sy -plist
is specified, then a property list will be emitted instead of the normal user-readable output.
.\"
.\"             -- APFS > changeCryptoUserPassphrase --
.It Sy changePassphrase | changeCryptoUserPassphrase | passwd
.Ar volumeDevice
.Nm -user
.Nm disk |
.Ar cryptoUserUUID
.Op Nm -oldPassphrase Ar oldPassphrase | Nm -oldStdinpassphrase
.Op Nm -newPassphrase Ar newPassphrase | Nm -newStdinpassphrase
.br
Change the passphrase of the given cryptographic user associated with the given APFS Volume.
.Pp
The old and new passphrases are specified in the same manner as
.Sy diskutil
.Sy apfs
.Sy addVolume.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > setCryptoUserPassphraseHint --
.It Sy setPassphraseHint | setCryptoUserPassphraseHint | hint
.Ar volumeDevice
.Nm -user
.Nm disk |
.Ar cryptoUserUUID
.Nm -hint Ar hintMessage | Nm -clear
.br
Set or clear an arbitrary hint string to aid recall of a passphrase for the given cryptographic user
associated with the given APFS Volume.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > encryptVolume --
.It Sy encryptVolume
.Ar volumeDevice
.Nm -user disk | Ar existingCryptoUserUUID
.Op Nm -passphrase Ar existingOrNewPassphrase | Nm -stdinpassphrase
.br
Start "background" encryption of a currently-unencrypted APFS Volume.
.Pp
You can supply an existing cryptographic user UUID, in which case you must supply its corresponding passphrase,
or you can supply
.Nm disk
(or the Disk/Volume UUID) and the corresponding passphrase of the "Disk User", provided the "Disk User" already exists.
.Pp
Alternatively, if no users exist yet on this APFS Volume, you can still supply
.Nm disk
(or the Disk/Volume UUID), and a "Disk User" will be created with a new passphrase which you supply.
.Pp
The passphrase, interactive or not, is specified in the same manner as
.Sy diskutil
.Sy apfs
.Sy addVolume.
.Pp
Ownership of the affected disks is required.
.\"
.\"             -- APFS > decryptVolume --
.It Sy decryptVolume
.Ar volumeDevice
.br
Start "background" decryption of a currently-encrypted APFS Volume.
No crypto credentials are required, but the APFS Volume must be unlocked.
.Pp
Ownership of the affected disks is required.
.\"
.\" List-End-APFSVerbs
.El
.\"
.\"             -- appleRAID --
.It Sy appleRAID | ar Ar raidVerb Op ...
.br
AppleRAID verbs can be used to create, manipulate and destroy AppleRAID volumes (Software RAID).
AppleRAID supports three basic types of RAID sets:
.\" List-Begin-AppleRAIDSetTypes
.Bl -bullet -offset indent
.It
"stripe" - Striped Volume (RAID 0)
.It
"mirror" - Mirrored Volume (RAID 1) 
.It
"concat" - Concatenated Volume (Spanning)
.\" List-End-AppleRAIDSetTypes
.El
.Pp
Of these three basic types, only the "mirror" type increases fault-tolerance.
Mirrors may have more than two disks to further increase their fault-tolerance.
Striped and concatentated volumes are, in fact, more vulnerable to faults than single disk volumes.
.Pp
From these basic types, "stacked" or "nested" RAID volumes can be created.
Stacked RAID sets that make use of mirrored RAID sets are fault-tolerant.
For example, these are some of the more common combinations of stacked RAID sets:
.\" List-Begin-StackedRAIDLevels
.Bl -bullet -offset indent
.It
RAID 50 - A striped RAID set of hardware RAID 5 disks.
.It
RAID 10 - A striped RAID set of mirrored RAID sets.
.It
RAID 0+1 - A mirrored RAID set of striped RAID sets.
.It
Concatenated Mirror - A concatenation of mirrored RAID sets.
.\" List-End-StackedRAIDLevels
.El
.Pp
When creating new RAID sets or adding disks, if possible, it is better to specify the entire disk instead of a partition on that disk.
This allows the software to reformat the entire disk using the most current partition layouts.
When using whole disks, the type of partitioning used is selected based on the platform type (PPC = APMFormat, Intel = GPTFormat).
GPT and APM partition formats cannot be mixed in the same RAID set.
.Pp
In addition to whole disk and partition device names, AppleRAID uses UUIDs to refer to existing RAID sets and their members.
Existing RAID sets may also be specified by mount point (e.g.
.Pa /Volume/raidset Ns ).
In many cases, using the UUID for the device argument is preferred because disk device names may 
change over time when disks are added, disks are removed or when the system is rebooted.
If RAID members have been physically disconnected from the system or are no longer responding, 
you must use the member's UUID as the command argument.
Messages in the system log will refer to RAID sets and their member disks by UUID.
For more information on specifying device arguments, see the
.Sy DEVICES
section below.
.Pp
AppleRAID is not a replacement for backing up your data.
Backups should be always be performed on a regular basis and before modifying any RAID set using these commands.
.Pp
The following is a list of
.Sy appleRAID
sub-verbs with their descriptions and individual arguments.
.br
.\"
.\" List-Begin-AppleRAIDVerbs
.Bl -hang -width "imageinfo"
.\"
.\"             -- appleRAID > list --
.It Sy list Op Nm -plist | Ar UUID
.br
Display AppleRAID volumes with current status and associated member disks.
If
.Ar UUID
is specified, only list the RAID set with that AppleRAID Set UUID.
If
.Sy -plist
is specified, then a property list will be emitted instead of user-formatted output.
The
.Sy -plist
and
.Ar UUID
arguments may not both be specified.
.Sy diskutil
.Sy listRAID
and
.Sy diskutil
.Sy checkRAID
are deprecated synonyms for
.Sy diskutil
.Sy appleRAID
.Sy list.
.\"
.\"             -- appleRAID > create  --
.It Sy create Nm mirror | stripe | concat
.Ar setName
.Ar format
.Ar devices Ar ...
.br
Create a new RAID set consisting of multiple disks and/or RAID sets.
.Ar setName
is used for both the name of the created RAID volume and the RAID
set itself (as displayed in
.Sy list Ns ).
e.g. 'diskutil createRAID stripe MyArray JHFS+ disk1 disk2 disk3 disk4'.
Ownership of the affected disks is required.
.Sy diskutil
.Sy createRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy create.
.\"
.\"             -- appleRAID > delete  --
.It Sy delete Ar raidVolume
.br
Destroy an existing RAID set.
If the RAID set is a mirror with a resizable file system,
.Sy delete
will attempt to convert
each of the member partitions back into a non-RAID volume while
retaining the contained file system.
For concatenated RAID sets with a resizable file system,
.Sy delete
will attempt to shrink the
file system to fit on the first member partition and convert that
to a non-RAID volume.
Ownership of the affected disks is required.
.Sy diskutil
.Sy destroyRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy delete.
.\"
.\"             -- appleRAID > repairMirror --
.It Sy repairMirror Ar raidVolume Ar newDevice
.br
Repair a degraded mirror by adding a "new" disk given as
.Ar newDevice
to the RAID mirror set whose exported disk device or set UUID is given as
.Ar raidVolume.
The new disk must be the same size or larger than the existing disks in the RAID set.
After running this command, you should manually remove the old (orphaned, failed) member(s) with
.Sy diskutil
.Sy appleRAID
.Sy remove.
Ownership of the affected disk is required.
.Sy diskutil
.Sy repairMirror
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy repairMirror.
.\"
.\"             -- appleRAID > add --
.It Sy add Ar type Ar newDevice Ar raidVolume
.br
Add a new member or hot spare to an existing RAID set.
.Ar Type
can be either
.Ar member
or
.Ar spare .
New disks are added live, the RAID volume does not need to be unmounted.
Mirrored volumes support adding both members and hot spares, concatenated volumes only support adding members.
When adding to a mirrored RAID set, the new disk must be the same size or larger than the existing disks in the RAID set.
Adding a hot spare to a mirror will enable autorebuilding for that mirror.
Adding a new member to a concatenated RAID set appends the member and expands the RAID volume.
Ownership of the affected disk is required.
.Sy diskutil
.Sy addToRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy add.
.\"
.\"             -- appleRAID > remove --
.It Sy remove Ar oldDevice Ar raidVolume
.br
Remove a member or spare from an existing RAID set.
Old disks are removed live; the RAID volume does not need to be unmounted.
For missing devices,
.Ar oldDevice
must be the device's UUID.
Online mirror members with a resizable file system will be converted to non-RAID volumes, spare and offline members will be marked free.
For concatenated RAID sets, only the last member can be removed.
For resizable file systems
.Sy remove
will first attempt to shrink the concatenated RAID set so that the file system fits on the remaining disks.
Ownership of the affected disk is required.
.Sy diskutil
.Sy removeFromRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy remove.
.\"
.\"             -- appleRAID > enable --
.It Sy enable Nm mirror | concat
.Ar device
.br
Convert a non-RAID disk partition containing a resizable file system
(such as JHFS+) into an unpaired mirror or single disk concatenated
RAID set.
Disks that were originally partitioned on Mac OS X 10.2 Jaguar or earlier 
or were partitioned to be Mac OS 9 compatible may not be resizable.
Ownership of the affected disk is required.
.Sy diskutil
.Sy enableRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy enable.
.\"
.\"             -- appleRAID > update --
.It Sy update Ar key Ar value Ar raidVolume
.br
Update the
.Ar key value
parameters of an existing RAID set.
Valid keys are:
.\" List-Begin-AppleRAIDKeys
.Bl -bullet -offset indent
.It
.Sy AutoRebuild
- If true, the system attempts to rebuild degraded mirrored volumes automatically.
When looking for devices for rebuild, AppleRAID first looks for hot spares and then degraded members.
Use a
.Ar value
of "1" for true and "0" for false.
.It
.Sy SetTimeout
- Controls how long the system waits (in seconds) for a missing device before degrading a mirrored raid set.
Also controls the amount of time you have to disconnect all devices from an unmounted mirror without degrading it.
.\" List-End-AppleRAIDKeys
.El
.Pp
Ownership of the affected disk is required.
.Sy diskutil
.Sy updateRAID
is a deprecated synonym for
.Sy diskutil
.Sy appleRAID
.Sy update.
.\"
.\" List-End-AppleRAIDVerbs
.El
.\"
.\"             -- coreStorage --
.It Sy coreStorage | cs Ar coreStorageVerb Op ...
.br
CoreStorage verbs can be used to create, manipulate and destroy CoreStorage volumes.
.Pp
CoreStorage maintains a world of virtual disks, somewhat like RAID, in which one can easily add or remove imported
backing store disks, as well as exported usable volumes, to or from a pool (or several pools). This provides the user
with flexibility in allocating their hardware; user or operating system data can span multiple physical disks seamlessly,
for example.
.Pp
Apple CoreStorage defines four types of objects, instances of which are uniquely represented by a UUID:
.\" List-Begin-CoreStorageObjects
.Bl -bullet -offset indent
.It
Logical Volume Group (LVG)
.It
Physical Volume (PV)
.It
Logical Volume Family (LVF)
.It
Logical Volume (LV)
.\" List-End-CoreStorageObjects
.El
.Pp
The Logical Volume Group (LVG) is the top or "pool" level; zero or more may exist during any OS boot time session.
.Pp
An LVG imports one or more Physical Volumes (PVs). A PV represents a device that feeds the LVG storage space;
a PV is normally real media but it can be a disk image or even an AppleRAID Set. A disk offered to be a PV must be a
partition and the encompassing scheme must be GPT.
.Pp
An LVG exports zero or more Logical Volume Families (LVFs). An LVF contains properties which govern and bind
together all of its descendant Logical Volumes (LVs). These properties provide settings for Full Disk Encryption (FDE)
(such as whether the LVG is encrypted, which users have access, etc) and other services.
However, at the present time, for new LVF creation, only zero or one LVF per LVG is supported.
.Pp
A Logical Volume Family (LVF) exports one or more Logical Volumes (LVs).
However, at the present time, only and exactly one LV per LVF is supported.
.Pp
A Logical Volume (LV) exports a dev node, upon which a file system (such as Journaled HFS+) resides.
.Pp
For more information on specifying device arguments, see the
.Sy DEVICES
section below.
.Pp
CoreStorage is not a replacement for backing up your data.
Backups should be always be performed on a regular basis and before modifying any CoreStorage volumes using these commands.
.Pp
The following is a list of
.Sy coreStorage
sub-verbs with their descriptions and individual arguments.
.br
.\"
.\" List-Begin-CoreStorageVerbs
.Bl -hang -width "imageinfo"
.\"
.\"             -- coreStorage > list --
.It Sy list Op Nm -plist | Ar UUID
.br
Display a tree view of the CoreStorage world for all current logical volume groups (LVGs) with
member disks (PVs) and exported volumes (LVFs and LVs), with properties and status for each level.
If
.Sy -plist
is specified then a property list will be emitted instead of the formatted tree output; the UUIDs can be
used with the
.Sy diskutil
.Sy coreStorage
.Sy information
verb to get properties for the object represented by that UUID.
If
.Ar UUID
is specified then an attempt is made to list only that UUID (whatever type of CoreStorage object it may represent).
The
.Sy -plist
and
.Ar UUID
arguments may not both be specified.
.\"
.\"             -- coreStorage > information --
.It Sy info | information
.Op Nm -plist
.Ar UUID | device
.br
Display properties of the CoreStorage object (LVG, PV, LVF, or LV) associated with the given CoreStorage
UUID or disk.
.\"
.\"             -- coreStorage > convert  --
.It Sy convert Ar device
.Op Nm -stdinpassphrase | -passphrase Op Ar passphrase
.br
Convert a regular Journaled HFS+ or Case-sensitive Journaled HFS+ volume
(must be on a partition and within a GPT partitioning scheme)
into a CoreStorage logical volume.
.Pp
If
.Sy -passphrase
is specified, the on-disk bytes will be encrypted. You will be prompted for a new passphrase
interactively, or you can specify the
.Ar passphrase
on the command line. Alternatively, if you specify
.Sy -stdinpassphrase
the standard input is read for the passphrase so that a program could execute
.Sy diskutil
and send the passphrase through a pipe without having to expose it as a command-line parameter.
.Pp
The volume is encrypted with an FDE "Disk" passphrase, which is distinct from the
"User" ID and passphrase combination which FileVault associates with a volume.
Therefore, if you want to encrypt a macOS "OS-bearing" volume
(with its user accounts), you must use FileVault in Security Preferences
or the contextual menu in the Finder.
.Pp
The volume must be resizable (the above types are) and also mounted. Conversion is done live and in-place;
targeting the boot volume is supported; as much of the conversion as possible is done before an eject or
reboot is necessary.
.Pp
After slightly shrinking the source volume to make room for CoreStorage data structures at the end, its partition
type is changed to Apple_CoreStorage and it becomes a CoreStorage Physical Volume.
A new CoreStorage Logical Volume Group is then created with this Physical Volume as the backing store,
followed by the creation of a Logical Volume Family and Logical Volume pair.
.Pp
At this point, the new CoreStorage PV/LVG/LVF/LV stack is ready for use, although the
"old" mountpoint must first be unmounted; yet it might not be unmountable. This will occur if the target
(now the PV) is the current boot volume.
.Pp
Just before exiting,
.Sy diskutil
.Sy coreStorage
.Sy convert
will try to unmount the target disk (which is now the "old" mount point and the new PV). If successful
(target is not the boot disk), the volume now becomes mounted from the LV. If unsuccessful (target is the boot disk),
a reboot is necessary.
.Pp
At this point, if no encryption was specified, all is done. Otherwise, the bytes-on-disk will begin to be
encrypted in-place by CoreStorage automatically "in the background" while the PV/LVG/LVF/LV stack continues
to be usable. Encryption progress may be monitored with
.Sy diskutil
.Sy coreStorage
.Sy list.
.Pp
When encryption is finished, a Disk passphrase will be required the next time the LV is ejected and re-attached.
If the LV is hosting the boot volume, this passphrase requirement will thus occur at the next reboot.
.Pp
Note that all on-disk data is not secured immediately; it is a deliberate
process of encrypting all on-disk bytes while the CoreStorage driver keeps publishing the (usable) LVG/LV.
.Pp
Ownership of the affected disk is required.
.\"
.\"             -- coreStorage > revert --
.It Sy revert Ar device | lvUUID
.Op Nm -stdinpassphrase
|
.Op Nm -passphrase Ar passphrase
|
.Op Nm -recoverykeychain Ar file
.br
Convert a CoreStorage logical volume back to its native type.
The volume must have been created by means of conversion, e.g. with
.Sy diskutil
.Sy coreStorage
.Sy convert.
.Pp
If the volume was not created with a passphrase, then simple ownership of the affected disk is required;
otherwise, a Disk passphrase must be supplied, either interactively or via one of the parameters or a keychain
file in the same manner as
.Sy diskutil
.Sy coreStorage
.Sy unlockVolume.
.\"
.\"             -- coreStorage > create --
.It Sy create | createLVG Ar lvgName Ar devices ...
.br
Create a CoreStorage logical volume group. The disks specified will become
the (initial) set of physical volumes; more than one may be specified. You can specify partitions (which will be re-typed to be
Apple_CoreStorage) or whole-disks (which will be partitioned as GPT and will contain an Apple_CoreStorage partition).
The resulting LVG UUID can then be used with createVolume below.
All existing data on the drive(s) will be lost.
Ownership of the affected disk is required.
.\"
.\"             -- coreStorage > delete --
.It Sy delete | deleteLVG Ar lvgUUID | lvgName
.br
Delete a CoreStorage logical volume group. All logical volume families with their logical volumes are removed, the
logical volume group is destroyed, and the now-orphaned physical volumes are erased and partition-typed as Journaled HFS+.
.\"
.\"             -- coreStorage > rename --
.It Sy rename | renameLVG Ar lvgUUID | lvgName Ar newName
.br
Rename a CoreStorage logical volume group. Do not confuse this name with the LV name or the volume name of the
file system volume on the LV.
.\"
.\"             -- coreStorage > createVolume --
.It Sy createVolume | createLV Ar lvgUUID | lvgName Ar type Ar name Ar size
.Op Nm -stdinpassphrase | -passphrase Op Ar passphrase
.br
Export a new logical volume family, with a new logical volume under it, out of a CoreStorage logical volume
group.
.Ar Type
is the file system personality to initialize on the new logical volume. Valid types
are Journaled HFS+ or Case-sensitive Journaled HFS+ or their aliases.
.Ar Size
is the amount of space to allocate from the parent LVG. It is given in the same manner as the
triplet description for the
.Sy partitionDisk
verb, and you can also specify with
.Sy %
a percentage of the currently remaining unallocated space in the LVG.
.Pp
If
.Sy -passphrase
or
.Sy -stdinpassphrase
is specified, in the same manner as with
.Sy diskutil
.Sy coreStorage
.Sy convert
above, on-disk data will be stored in an encrypted form as the Logical Volume is filled; otherwise, the data
will remain plain.
.\"
.\"             -- coreStorage > deleteVolume --
.It Sy deleteVolume | deleteLV Ar lvUUID | device
.br
Remove an exported logical volume (and its logical volume family as appropriate) from a CoreStorage logical volume
group. Any data on that logical volume will be lost.
This operation will thus result in an increase in free space in the logical volume group.
.Pp
It is assumed that the logical volume is used as a backing store for a file system; therefore, an unmount attempt
is made which must succeed before the removal of the logical volume is done.
.\"
.\"             -- coreStorage > encryptVolume --
.It Sy encryptVolume | encryptLV
.Ar lvUUID | device
.Op Nm -stdinpassphrase
|
.Op Nm -passphrase Ar passphrase
.br
Begin a live background process of encrypting the on-disk backing bytes of an existing plain
CoreStorage logical volume (LV).
.Pp
That is, the on-disk bytes that are backing the user data are all visited,
read, and re-written in an encrypted form; this process can take a long time (minutes to hours). This process
continues seamlessly across reboots. The logical volume remains usable at all times.
When this command returns, the operation will be ongoing; you can check progress with
.Sy diskutil
.Sy coreStorage
.Sy list.
.Pp
The entire logical volume family (LVF) is affected since all LVs in an LVF share the same encryption settings.
.Pp
Any new user data written while this background operation is in progress will be in encrypted form.
.Pp
Specifying
.Sy -passphrase
or
.Sy -stdinpassphrase
or interactively entering a passphrase is mandatory; you do so in the same manner as with
.Sy diskutil
.Sy coreStorage
.Sy convert
above.
.Pp
The volume is encrypted with an FDE "Disk" passphrase, which is distinct from the
"User" ID and passphrase combination which FileVault associates with a volume.
Therefore, if you want to encrypt a macOS "OS-bearing" volume
(with its user accounts), you must use FileVault in Security Preferences
or the contextual menu in the Finder.
.\"
.\"             -- coreStorage > decryptVolume --
.It Sy decryptVolume | decryptLV
.Ar lvUUID | device
.Op Nm -stdinpassphrase
|
.Op Nm -passphrase Ar passphrase
.br
Begin a live background process of decrypting the on-disk backing bytes of an existing encrypted
CoreStorage logical volume (LV). Bytes are read, decrypted, and written back to disk in plain form.
The LV must be unlocked before beginning this operation.
.Pp
Like as in
.Sy diskutil
.Sy coreStorage
.Sy encryptVolume
above, all on-disk bytes are visited and converted, the process is seamless across reboots, the
logical volume remains usable at all times, the entire logical volume family (LVF) is affected,
any new user data written will be in plain form, and the operation will be ongoing when this
command returns.
.Pp
Credentials must be supplied; you can use
.Sy -passphrase
or
.Sy -stdinpassphrase
to supply a Disk passphrase,
or you can specify that a recovery keychain file be used, in the same manner as
.Sy diskutil
.Sy coreStorage
.Sy unlockVolume.
.\"
.\"             -- coreStorage > unlockVolume --
.It Sy unlockVolume | unlockLV
.Op Nm -nomount
.Ar lvUUID
.Op Nm -stdinpassphrase
|
.Op Nm -passphrase Ar passphrase
|
.Op Nm -recoverykeychain Ar file
.br
Unlock a logical volume and file system, causing it to be attached and mounted.
.Pp
Data is then accessible in plain form to the file system and applications,
while the on-physical-disk backing bytes remain in encrypted form.
.Pp
The locked state means that the CoreStorage driver has not been given authentication
information (a passphrase) to interpret the encrypted bytes on disk and thus export a dev node.
This verb unlocks a logical volume family (LVF) and its logical volumes (LVs) by providing that
authentication; as the LVs thus appear as dev nodes,
any file systems upon them are automatically mounted unless the
.Sy -nomount
option is given.
.Pp
To re-lock the volume, make it offline again by ejecting it, e.g. with
.Sy diskutil
.Sy eject.
.Pp
Credentials must be supplied. You must either supply a Disk passphrase interactively,
with one of the
.Sy -passphrase
or
.Sy -stdinpassphrase
parameters in the same manner as with
.Sy diskutil
.Sy coreStorage
.Sy convert
above, or you must specify that a recovery keychain file be used.
.Pp
You can specify
.Sy -recoverykeychain
with a path to a keychain file.
The keychain must be unlocked; see
.Ns Xr security 1 
for more information.
.\"
.\"             -- coreStorage > changeVolumePassphrase --
.It Sy changeVolumePassphrase | passwd Ar lvUUID
.Op Nm -recoverykeychain Ar file
.Op Nm -oldpassphrase Ar oldpassphrase
.Op Nm -newpassphrase Ar newpassphrase
.Op Nm -stdinpassphrase
.br
Change the Disk passphrase of an existing encrypted volume. It need not be unlocked nor mounted. The parameters, while variously optional,
must be given in the above order.
.Pp
You must authenticate either via the
.Sy -oldpassphrase
parameter, via the
.Sy -stdinpassphrase
parameter (with newline or eof-terminated data given to stdin), or via an interactive prompt (if no parameters are given),
in the same manner as
.Sy diskutil
.Sy coreStorage
.Sy convert
above.
Alternatively, you can authenticate by specifying
.Sy -recoverykeychain
with a path to a keychain file.
.Pp
A new passphrase must then be supplied, again via one of the three methods above (interactive,
.Sy -newpassphrase,
or
.Sy -stdinpassphrase).
.Pp
If you are supplying both the old and new passphrases via stdin, they must be separated with a newline character.
.Pp
Only the Disk passphrase is supported; you cannot change credentials for various users that were set up with
FileVault or the Finder; to edit credentials for such users, you should use
.Sy fdesetup
(8).
.\"
.\"             -- coreStorage > resizeVolume --
.It Sy resizeVolume | resizeLV
.Ar lvUUID | device
.Ar size
.br
Resize a logical volume (LV). If you shrink an LV, more space becomes available in its logical volume group (LVG);
if you grow an LV, less space becomes available. You can check the free space with
.Sy diskutil
.Sy coreStorage
.Sy list.
The file system volume which resides inside the LV is grown or shrunk as needed.
.Pp
You can specify a
.Ar size
of zero
.Sy (0)
to fill up all remaining space in the parent LVG with the given LV.
.\"
.\"             -- coreStorage > resizeDisk --
.It Sy resizeDisk | resizePV
.Ar pvUUID
.Ar size
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
.br
Resize a physical volume (PV). If you shrink a PV, less space becomes available in its logical volume group (LVG);
if you grow a PV, more space becomes available. The partition in which the PV resides is changed to accommodate, and
the associated booter partition, if present, is automatically moved.
.Pp
Note that you cannot ordinarily grow a PV unless there is
free space in the partition map beyond it; note also that you cannot ordinarily shrink a PV unless the LVG has some free space in
it (e.g. by shrinking an overlying LV first).
.Pp
When decreasing the size (shrinking), new partitions may optionally be created to fill the newly-freed space.
To do this, specify the
.Ar format,
.Ar name,
and
.Ar size
parameters in the same manner as the triplet description for the
.Sy partitionDisk
verb.
.Pp
You can specify a
.Ar size
of zero
.Sy (0)
to fill up all remaining space to the next partition or the end of the partition map, if possible.
.\"
.\"             -- coreStorage > resizeStack --
.It Sy resizeStack Ar lvUUID | device
.Op Ar pvUUID
.Ar size
.Op Ar part1Format Ar part1Name Ar part1Size Ar part2Format Ar part2Name Ar part2Size Ar part3Format part3Name part3Size Ar ...
.br
Combine the actions of
.Sy diskutil
.Sy coreStorage
.Sy resizePV
and
.Sy diskutil
.Sy coreStorage
.Sy resizeLV
in the correct sequence in order to effect a shrink or a grow in an entire LVG setup.
.Pp
This is done by making a change to the size of a logical
volume (LV), after or before which (one of its) physical volume(s) (PV) also changes its size accordingly.
The (HFS) file system "on top of" the LV and the disk partition "below" the PV, as well as the location of the PV's
associated booter partition, are automatically adjusted.
.Pp
When decreasing the size (shrinking), new partitions may optionally be created to fill the newly-freed space.
To do this, specify the
.Ar format,
.Ar name,
and
.Ar size
parameters in the same manner as the triplet description for the
.Sy partitionDisk
verb.
.Pp
Since an LVG might have one (e.g. Full Disk Encryption (FDE), aka FileVault),
two (e.g. Fusion), or even three (certain Boot Camp configurations) PVs, a specific PV
must be chosen. You can have this command choose one for you, or you can specify the PV UUID directly. If you do not specify a
PV, the one which has previously been marked for this purpose is used; if no mark, a policy algorithm is applied.
.Pp
If your new LV size represents a grow of the existing LV size, then the PV size will take up
more space on disk, thus creating a larger LVG for the larger LV to live in.
If your new LV size represents a shrink, then the PV size will take up less space
on disk, thus creating a smaller LVG, which is enough for the smaller LV to live in. The
magnitude of the size change you specify (which is for the LV) causes an exact size change in
the PV if you conform to partition rounding (alignment) restrictions; the corresponding LV change
may be greater because it is under additional alignment restrictions imposed by CoreStorage and HFS.
.Pp
The "spilling over" of size change effects from one PV onto another is not supported; only and exactly
one PV is affected by this operation. Grows or shrinks whose effects don't
"fit" the designated PV will result in an error message and no effect.
For example, you can't do a shrink on a multi-PV setup
such that the designated PV should shrink to zero size and so effectively should disappear.
Nor can you do a grow
which would necessitate the growth of some other PV or the addition of new PVs.
.Pp
As in
.Sy diskutil
.Sy coreStorage
.Sy resizePV ,
note that you cannot grow unless there is free space in the partition map beyond the designated PV,
which is not normally the case because you usually don't leave gaps of free space on your disk.
.Pp
You can specify a
.Ar size
of zero
.Sy (0)
to fill up all remaining space to the partition following the designated PV's booter
or to the end of the partition map, if possible.
.\"
.\" List-End-CoreStorageVerbs
.El
.\" List-End-Verbs
.El
.\"
.\"
.\"
.Sh DEVICES
A device parameter for any of the above commands (except where explicitly required otherwise) can usually
be any of the following:
.\" List-Begin-DeviceSpecifiers
.Bl -bullet -offset indent
.It
The
.Sy disk identifier
(see below).
Any entry of the form of
.Pa disk* ,
e.g.
.Pa disk1s9 .
.It
The device node entry containing the
.Sy disk identifier .
Any entry of the form of
.Pa /dev/[r]disk* ,
e.g.
.Pa /dev/disk2 .
.It
The volume mount point.
Any entry of the form of
.Pa /Volumes/* , 
e.g.
.Pa /Volumes/Untitled .
In most cases, a "custom" mount point e.g.
.Pa /your/custom/mountpoint/here
is also accepted.
.It
The URL form of any of the volume mount point forms described above.
E.g.
.Pa file:///Volumes/Untitled
or
.Pa file:/// .
.It
A UUID.  Any entry of the form of
e.g.
.Pa 11111111-2222-3333-4444-555555555555 .
The UUID can be a "media" UUID which IOKit places in an IOMedia node as derived from e.g. a GPT map's partition UUID,
or it can be an AppleRAID (or CoreStorage) set (LV) or member (PV) UUID.
.It
A volume name,
e.g.
.Pa Untitled .
This match is only attempted if the given device is not of the form
.Pa [/dev/][r]disk* ,
nor
.Pa [/Volumes/]* .
The match attempt is against the intrinsic volume label, not against
the terminal component, if mounted, of its mount point.
.\" List-End-DeviceSpecifiers
.El
.\"
.\"
.\"
.Sh DISK IDENTIFIER
The (BSD)
.Sy disk identifier
string variously identifies a physical or logical device unit,
a session (if any) upon that device,
a partition (slice) upon that session (if any),
or a virtual logical volume.
It may take the form of
.Pa diskU ,
.Pa diskUsS ,
.Pa diskUsQ ,
or
.Pa diskUsV ,
where U, S, Q and V
are positive decimal integers (possibly multi-digit), and where:
.\" List-Begin-BSDComponents
.Bl -bullet -offset indent
.It
.Pa U
is the device unit.
It may refer to hardware (e.g. a hard drive, optical drive, or memory card) or a virtual "drive"
constructed by software (e.g. an AppleRAID Set, disk image, CoreStorage LV, etc).
.It
.Pa Q
is the session and is only included for optical media; it refers to the number of times recording has taken
place on the currently-inserted medium (disc).
.It
.Pa S
is the "slice"; it refers to a partition.
Upon this partition, the raw data that underlies a user-visible file system is
usually present, but it may also contain specialized data for certain 3rd-party database programs, or data required for
the system software (e.g. EFI partitions, booter partitions, APM partition map data, etc), or, notably, it might contain
backing-store physical volumes for AppleRAID, CoreStorage, APFS, or 3rd-party Storage Systems.
.It
.Pa V
is an APFS "Volume"; it refers to a virtual logical volume that is shared out of an APFS Container.
For example, if an Apple_APFS-typed partition is on disk5s2,
then disk5s2 is termed the APFS Physical Store which is imported into an APFS Container. The APFS Container might then export
e.g. disk8s1, which is termed an APFS Volume, which is mountable as a file system. Multiple APFS Volumes can be exported
from a single APFS Container.
.\" List-End-BSDComponents
.El
.Pp
Some units (e.g. floppy disks, RAID sets) contain file system data upon their "whole" device instead of containing
a partitioning scheme with partitions.
.Pp
Note that some of the forms appear the same and must be distinguished by context.
For example,
.Pa diskUsQ ,
.Pa diskUsS ,
and
.Pa diskUsV
are all 2-part forms that can mean different things: For non-optical media, it identifies a partition (on a partition map) upon
which (file system) data is stored; for optical media, it identifies a session upon which an entire partition map (with its
partitions with file systems) is stored; for an APFS setup, it identifies an APFS Volume. As another example,
in "stacked" cases (CoreStorage on AppleRAID or APFS on AppleRAID), the 1-part
.Pa diskU
form becomes a CoreStorage PV or APFS PhysicalStore, in contrast with the more-common 2-part form.
.Pp
It is important for software to avoid relying on numerical ordering of any of the parts.
Activities including but not limited to partition deletions and insertions, partition resizing, virtual volume deletions and additions,
device ejects and attachments due to media insertion cycles, plug cycles, authentication lock cycles or reboots, can all cause (temporary)
gaps and non-increments in the numerical ordering of any of the parts. You must rely on more persistent means of identification, such
as the various UUIDs.
.\"
.\"
.\"
.Pp
.Sh SIZES
Wherever a size is emitted as an output, it is presented as a base-ten approximation to the precision of one fractional decimal
digit and a base-ten SI multiplier, often accompanied by a precise count in bytes. Scripts should refrain from parsing this
human-readable output and use the
.Sy -plist
option instead.
.Pp
Wherever a
.Ar size
is to be supplied by you as an input, you can provide values in several different ways, some absolute and some context-sensitive.
All suffixes described below are interpreted in a case-insensitive manner. The
.Sy B
is optional.
.Pp
The most common way is to specify absolute values as a decimal number, possibly followed by a period and a
decimal fraction, followed without whitespace with a suffix as follows:
.\" List-Begin-SizeSuffixes-1
.Bl -bullet -offset indent
.It
.Sy B
is
.Sy bytes
(not blocks) where the multiplier is 1.
This suffix may be omitted.
.It
.Sy K[B]
is power of ten
.Sy kilobytes
where the multiplier is 1000 (1 x 10^3).
.It
.Sy M[B]
is power of ten
.Sy megabytes
where the multiplier is 1000000 (1 x 10^6).
.It
.Sy G[B]
is power of ten
.Sy gigabytes
where the multiplier is 1000000000 (1 x 10^9).
.It
.Sy T[B]
is power of ten
.Sy terabytes
where the multiplier is 1000000000000 (1 x 10^12).
.It
.Sy P[B]
is power of ten
.Sy petabytes
where the multiplier is 1000000000000000 (1 x 10^15).
.It
.Sy E[B]
is power of ten
.Sy exabytes
where the multiplier is 1000000000000000000 (1 x 10^18).
.\" List-End-SizeSuffixes-1
.El
.Pp
You can also use the following suffixes:
.\" List-Begin-SizeSuffixes-2
.Bl -bullet -offset indent
.It
.Sy S | UAM
("sectors") is
.Sy 512-byte
.Sy units
(device-independent) where the multiplier is always 512.
.It
.Sy DBS
("device block size") is the
.Sy device-dependent
native block size of the encompassing whole disk, if applicable,
where the multiplier is often 512, but not always; indeed it might not be a power of two.
.It
.Sy Ki[B]
is power of two
.Sy kibibytes
where the multiplier is 1024 (1 x 2^10).
.It
.Sy Mi[B]
is power of two
.Sy mebibytes
where the multiplier is 1048576 (1 x 2^20).
.It
.Sy Gi[B]
is power of two
.Sy gibibytes
where the multiplier is 1073741824 (1 x 2^30).
.It
.Sy Ti[B]
is power of two
.Sy tebibytes
where the multiplier is 1099511627776 (1 x 2^40).
.It
.Sy Pi[B]
is power of two
.Sy pebibytes
where the multiplier is 1125899906842624 (1 x 2^50).
.It
.Sy Ei[B]
is power of two
.Sy exbibytes
where the multiplier is 1152921504606846976 (1 x 2^60).
.\" List-End-SizeSuffixes-2
.El
.Pp
In certain contexts (e.g. when specifying partition triplets) you can provide a relative value as follows:
.\" List-Begin-SizeSuffixes-3
.Bl -bullet -offset indent
.It
.Sy %
(with a preceding number) is a
.Sy percentage
of the whole-disk size, the partition map size, or other allocatable size, as appropriate by context.
Use of
.Sy %
is not supported in all situations.
.It
.Sy R
(with no preceding number) specifies the
.Sy remainder
of the whole-disk size or other allocatable size after all other triplets in the group are taken into account.
It need not be in the last triplet.  It must only appear in at most one triplet among all triplets.
Use of
.Sy R
is not supported in all situations.
.\" List-End-SizeSuffixes-3
.El
.Pp
You can provide an operating system-defined constant value as follows:
.\" List-Begin-SizeSuffixes-4
.Bl -bullet -offset indent
.It
.Sy %recovery%
(with no preceding number) is the
customary size of macOS Recovery Partitions.
.\" List-End-SizeSuffixes-4
.El
.Pp
Note again that
.Sy B
refers to bytes and
.Sy S
and
.Sy UAM
refer to a constant multiplier of 512; the latter are useful when working with tools such as
.Sy gpt
(8) or
.Sy df
(1).  Note also that this multiplier is not a "block" size as actually implemented by the
underlying device driver and/or hardware, nor is it an "allocation block", which is a
file system's minimum unit of backing store usage, often formatting-option-dependent.
.Pp
Examples: 10G (10 gigabytes), 4.23tb (4.23 terabytes), 5M (5 megabytes), 4GiB (exactly 2^32 bytes),
126000 (exactly 126000 bytes), 25.4% (25.4 percent of whole disk size).
.Sh FORMAT
The
.Pa format
parameter for the erasing and partitioning verbs is the file system personality name.
You can determine this name by looking in a file system bundle's
.Pa /System/Library/Filesystems/<fs>.fs/Contents/Info.plist
and looking at the keys for the
.Sy FSPersonalities
dictionary, or by using the
.Sy listFilesystems
verb, which also lists shortcut aliases for common
personalities (these shortcuts are defined by
.Sy diskutil
for use with it only).
.Pp
Common examples include JHFS+, JHFSX, MS-DOS, etc, as nicknames for the canonical
forms from the file system bundles such as "Case-sensitive HFS+".
.Pp
.Sh EXAMPLES
Erase a disk 
.br
diskutil eraseDisk JHFS+ Untitled disk3
.Pp
Erase a volume 
.br
diskutil eraseVolume HFS+ UntitledHFS /Volumes/SomeDisk
.Pp
Partition a disk with three partitions
.br
diskutil partitionDisk disk3 3 HFSX Name1 10G JHFS+ Name2 10G MS-DOS NAME3 10G
.Pp
Partition a disk with the APM partitioning scheme
.br
diskutil partitionDisk disk3 APM HFS+ vol1 25% Journaled\\ HFS+ vol2 25% Journaled\\ HFS+ vol3 50% Free\\ Space volX 0%
.Pp
Partition a disk with the GPT partitioning scheme
.br
diskutil partitionDisk disk3 GPT HFS+ vol1 25% MS-DOS VOL2 25% HFS+ vol3 50% Free\\ Space volX 0% 
.Pp
Resize a volume and create a volume after it, using all remaining space
.br
diskutil resizeVolume /Volumes/SomeDisk 50g MS-DOS DOS 0b
.Pp
Resize a volume and leave all remaining space as unused
.br
diskutil resizeVolume /Volumes/SomeDisk 12g
.Pp
Convert a disk to Core Storage and encrypt it
.br
diskutil coreStorage convert disk3s2 -passphrase
.Pp
Shrink your Core Storage PV in order to make space for a Boot Camp volume
.br
subtract desired Windows size from LV size, to be new LV size, i.e. 150g
.br
diskutil coreStorage list
.br
diskutil coreStorage resizeStack
.Ar LVUUID
.Ar PVUUID
150g ms-dos BOOTCAMP 0
.Pp
Revert a disk from Core Storage back to plain HFS, possibly decrypting
.br
diskutil coreStorage revert disk5
.Pp
Create a Core Storage setup "manually"
.br
diskutil coreStorage createLVG LVG1 disk0s2 disk1s2
.br
diskutil cs list
.br
diskutil cs createLV
.Ar LVGUUID
jhfs+ LVG1-Vol1 100%
.Pp
Remove a partition
.br
diskutil eraseVolume Free\\ Space not disk0s4
.Pp
Merge two partitions into a new partition
.br
diskutil mergePartitions JHFS+ not disk1s3 disk1s5
.Pp
Split a partition into three new ones
.br
diskutil splitPartition /Volumes/SomeDisk JHFS+ vol1 12g MS-DOS VOL2 8g JHFS+ vol3 0b
.Pp
Create a RAID 
.br
diskutil createRAID mirror MirroredVolume JHFS+ disk1 disk2
.Pp
Destroy a RAID 
.br
diskutil destroyRAID /Volumes/MirroredVolume
.Pp
Repair a damaged RAID 
.br
diskutil repairMirror /Volumes/MirroredVolume disk3
.Pp
Convert volume into RAID volume
.br
diskutil enableRAID mirror /Volumes/ExistingVolume
.Pp
Erase a partition and shrink to add an associated Recovery Partition
.br
diskutil splitPartition disk8s2 JHFS+ MacHD R %Apple_Boot% %noformat% %recovery%
.\"
.\"
.\"
.Pp
.Sh SEE ALSO
.Ns Xr hdiutil 1 ,
.Ns Xr mount 8 ,
.Ns Xr umount 8 ,
.Ns Xr diskmanagementd 8 ,
.Ns Xr diskmanagementstartup 8 ,
.Ns Xr diskarbitrationd 8 ,
.Ns Xr corestoraged 8 ,
.Ns Xr fdesetup 8 ,
.Ns Xr ioreg 8 ,
.Ns Xr newfs_hfs 8 ,
.Ns Xr fsck_hfs 8 ,
.Ns Xr authopen 1 ,
.Ns Xr hfs.util 8 ,
.Ns Xr msdos.util 8 ,
.Ns Xr ufs.util 8 ,
.Ns Xr drutil 1 ,
.Ns Xr vsdbutil 8
.\"
.\"
.\"
.Pp
.Sh ERRORS
.Sy diskutil
will exit with status 0 if successful or 1 if it cannot complete the requested operation;
this includes cases in which usage text is printed.
Before
.Sy diskutil
returns with status 1, it prints a message which might include
an explanation local to diskutil,
an error string from the DiskManagement or MediaKit frameworks,
an underlying POSIX error, or some combination.
.\"
.\"
.\"
.Pp
.Sh HISTORY
The eraseDisk and partitionDisk verbs had an option to add Mac OS 9 drivers (in partitions designated for that purpose);
there was also a repairOS9Permissions verb.
These have been removed.
.Pp
Starting with Mac OS X 10.11, the verify- and repairPermissions verbs have been removed.
.Pp
Starting with Mac OS X 10.6, the input and output notation of disk and partition sizes use power-of-10 suffixes.
In the past this has been power-of-2, regardless of the suffix (e.g. G, Gi, GiB) used for display or accepted as input.
Starting with Mac OS X 10.11, the
.Sy B
suffix is optional even for "bare" numeric values.
.Pp
Starting with macOS 10.12, the plist output of partitions from
.Sy diskutil list -plist
is presented in on-disk (not BSD slice) order, as the human-readable output always has been. This
mimics the order of outputs from programs such as
.Sy gpt
(1).
