.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simple 3"
.TH Simple 3 "2006-07-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::AppleEvents::Simple \- Simple access to Mac::AppleEvents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        #!perl \-w
\&        use Mac::AppleEvents::Simple;
\&        use Mac::Files;  # for NewAliasMinimal
\&        $alias = NewAliasMinimal(scalar MacPerl::Volumes);
\&        do_event(qw/aevt odoc MACS/, "\*(Aq\-\-\-\-\*(Aq:alis(\e@\e@)", $alias);
\&
\&        # [...]
\&        use Mac::Errors \*(Aq$MacError\*(Aq;
\&        use Mac::AppleEvents;  # for kAENoReply
\&        $evt = build_event(qw/aevt odoc MACS/, "\*(Aq\-\-\-\-\*(Aq:alis(\e@\e@)", $alias);
\&        die "There was a problem: $MacError" if $^E;
\&        $evt\->send_event(kAENoReply);
\&        die "There was a problem: $MacError" if $^E;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Requirements"
.IX Subsection "Requirements"
For MacPerl 5.2.0r4, you should have the latest cpan-mac distribution:
.PP
.Vb 1
\&        http://sourceforge.net/projects/cpan\-mac/
.Ve
.PP
For MacPerl 5.6.1 and up, everything you need is included.
.PP
For Mac \s-1OS X,\s0 you should have the latest Mac::Carbon:
.PP
.Vb 1
\&        http://sourceforge.net/projects/macperl/
.Ve
.PP
Also note the differences between MacPerl and perl on Mac \s-1OS X\s0 listed
in Mac::Carbon, especially regarding \f(CW$^E\fR.
.SS "Overview"
.IX Subsection "Overview"
This is just a simple way to do Apple Events.  The example above was 
previously done as:
.PP
.Vb 9
\&        #!perl \-w
\&        use Mac::AppleEvents;
\&        use Mac::Files;
\&        $alias = NewAliasMinimal(scalar MacPerl::Volumes);
\&        $evt = AEBuildAppleEvent(qw/aevt odoc sign MACS 0 0/,
\&                "\*(Aq\-\-\-\-\*(Aq:alis(\e@\e@)", $alias) or die $MacError;
\&        $rep = AESend($evt, kAEWaitReply) or die $MacError;
\&        AEDisposeDesc($rep);
\&        AEDisposeDesc($evt);
.Ve
.PP
The building, sending, and disposing is done automatically.  The function 
returns an object containing the parameters.  (Previously, the \f(CW\*(C`AEPrint\*(C'\fR 
results of \f(CW\*(C`AEBuildAppleEvent\*(C'\fR and \f(CW\*(C`AESend\*(C'\fR would be in \f(CW\*(C`$event\->{EVENT}\*(C'\fR 
\&\f(CW\*(C`$event\->{REPLY}\*(C'\fR, but this was wasting way too much memory, as some of
these things got big; you can call \f(CW\*(C`AEPrint($event\->{REP})\*(C'\fR yourself).
.PP
Also, the Mac::AppleEvents::Simple method will launch the application for
you, whereas the Mac::AppleEvents method requires the program to be running
already (or launched via Mac::Processes or Mac::Apps::Launch).  Launching
works only when the target is an app signature or bundle \s-1ID.\s0
.PP
The raw AEDesc forms are in \f(CW\*(C`$event\->{EVT}\*(C'\fR and \f(CW\*(C`$event\->{REP}\*(C'\fR.
So if I also \f(CW\*(C`use\*(C'\fR'd the Mac::AppleEvents module (or got the symbols via
\&\f(CW\*(C`use Mac::AppleEvents::Simple \*(Aq:all\*(Aq\*(C'\fR), I could extract the direct
object from the reply like this:
.PP
.Vb 1
\&        $dobj = AEPrint(AEGetParamDesc($event\->{REP}, keyDirectObject));
.Ve
.PP
An easier way to get the direct object data, though, is with the \f(CW\*(C`get\*(C'\fR
method, described below.
.PP
The sending of the event uses as its defaults (\f(CW\*(C`kAEWaitReply\*(C'\fR,
\&\f(CW\*(C`kAENormalPriority\*(C'\fR, \f(CW\*(C`kNoTimeout\*(C'\fR).  To use different parameters, use
\&\f(CW\*(C`build_event\*(C'\fR with \f(CW\*(C`send_event\*(C'\fR.
.PP
Setting \f(CW\*(C`$Mac::AppleEvents::Simple::SWITCH = 1\*(C'\fR forces the target app to
go to the front on sending an event to it.  This works only when
the target is an app signature or bundle \s-1ID.\s0
.PP
Sending an event with \f(CW\*(C`send_event\*(C'\fR or \f(CW\*(C`do_event\*(C'\fR will check for errors
automatically, and if there is an error and \f(CW$Mac::AppleEvents::Simple::WARN\fR
is true, a warning will be sent to \f(CW\*(C`STDERR\*(C'\fR.  You can also check \f(CW$^E\fR
after each call, or check the values of \f(CW\*(C`$event\->{ERRNO}\*(C'\fR and
\&\f(CW\*(C`$event\->{ERROR}\*(C'\fR.
.PP
If the event reply itself contains a \f(CW\*(C`errn\*(C'\fR or \f(CW\*(C`errs\*(C'\fR parameter, these
will also be placed in \f(CW\*(C`$event\->{ERRNO}\*(C'\fR and \f(CW\*(C`$event\->{ERROR}\*(C'\fR
and \f(CW$^E\fR as appropriate.
.PP
You may decide to roll your own error catching system, too.  In this
example, the error is returned in the direct object parameter.
.PP
.Vb 3
\&        my $event = do_event( ... );
\&        die $MacError if $^E;  # catch execution errors
\&        my_warn_for_this_app($event);  # catch AE reply errors
\&
\&        sub my_warn_for_this_app {
\&                my $event = shift;
\&                my $error = AEGetParamDesc($event\->{REP}, keyDirectObject);
\&                if ($error) {
\&                        my $err = $error\->get;
\&                        if ($err =~ /^\-\ed+$/ && $^W) {
\&                                warn "Application error: $err";
\&                        }
\&                        AEDisposeDesc($error);
\&                }
\&        }
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "[$EVENT =] do_event(\s-1CLASSID, EVENTID, TARGET, FORMAT, PARAMETERS ...\s0)" 4
.IX Item "[$EVENT =] do_event(CLASSID, EVENTID, TARGET, FORMAT, PARAMETERS ...)"
The first three parameters are required.  The \s-1FORMAT\s0 and \s-1PARAMETERS\s0
are documented elsewhere; see Mac::AppleEvents and macperlcat.
.Sp
\&\s-1TARGET\s0 may be a four-character app \s-1ID\s0 or a hashref containing \s-1ADDRESSTYPE\s0
and \s-1ADDRESS. \s0 Examples:
.Sp
.Vb 7
\&        { typeApplSignature()       => \*(Aq...\*(Aq            }  # default
\&        { typeTargetID()            => pack_ppc(...)    }  # Mac OS only
\&        { typeTargetID()            => pack_eppc(...)   }  # Mac OS only
\&        { typeApplicationURL()      => pack_eppc_x(...) }  # Mac OS X
\&        { typeProcessSerialNumber() => pack_psn(...)    }
\&        { typeKernelProcessID()     => pack_pid(...)    }  # Mac OS X only
\&        { typeBundleID()            => \*(Aq...\*(Aq            }  # Mac OS X only
.Ve
.Sp
See the pack functions below for details.
.ie n .IP "$EVENT = build_event(\s-1CLASSID, EVENTID, TARGET, FORMAT, PARAMETERS ...\s0)" 4
.el .IP "\f(CW$EVENT\fR = build_event(\s-1CLASSID, EVENTID, TARGET, FORMAT, PARAMETERS ...\s0)" 4
.IX Item "$EVENT = build_event(CLASSID, EVENTID, TARGET, FORMAT, PARAMETERS ...)"
This is for delayed execution of the event, or to build an event that will be 
sent specially with \f(CW\*(C`send_event\*(C'\fR.  Build it with \f(CW\*(C`build_event\*(C'\fR, and then 
send it with \f(CW\*(C`send_event\*(C'\fR method.  The parameters are the same as
\&\f(CW\*(C`do_event\*(C'\fR.
.ie n .IP "$EVENT\->send_event([\s-1GETREPLY, PRIORITY, TIMEOUT\s0]);" 4
.el .IP "\f(CW$EVENT\fR\->send_event([\s-1GETREPLY, PRIORITY, TIMEOUT\s0]);" 4
.IX Item "$EVENT->send_event([GETREPLY, PRIORITY, TIMEOUT]);"
For sending events differently than the defaults, which are \f(CW\*(C`kAEWaitReply\*(C'\fR,
\&\f(CW\*(C`kAENormalPriority\*(C'\fR, and \f(CW\*(C`kNoTimeout\*(C'\fR, or for re-sending an event.  The
parameters are sticky for a given event, so:
.Sp
.Vb 2
\&        $evt\->send_event(kAENoReply);
\&        $evt\->send_event;  # kAENoReply is still used
.Ve
.ie n .IP "$EVENT\->handle_event(\s-1CLASSID, EVENTID, CODE\s0 [, \s-1SYS\s0]);" 4
.el .IP "\f(CW$EVENT\fR\->handle_event(\s-1CLASSID, EVENTID, CODE\s0 [, \s-1SYS\s0]);" 4
.IX Item "$EVENT->handle_event(CLASSID, EVENTID, CODE [, SYS]);"
\&\fBNote\fR: Untested under Mac \s-1OS X. \s0 Testing and patches welcome.
.Sp
Sets up an event handler by passing \s-1CLASSID\s0 and \s-1EVENTID\s0 of the event
to be handled.  If \s-1SYS\s0 is true, then it sets up a system-wide event handler,
instead of an application-wide event handler.
.Sp
\&\s-1CODE\s0 is a code reference that will be passed three parameters:
a Mac::AppleEvents::Simple object, the \s-1CLASSID,\s0 and the \s-1EVENTID.\s0
The object will work similarly to a regular object.  The \s-1REP\s0 and \s-1EVT\s0
parameters are switched (that is, you get the event in the \s-1REP\s0 parameter,
and the reply to be sent is in the \s-1EVT\s0 parameter).  This is so the other
methods will work just fine, and since you will only be using actual methods
on the object and not accessing its data directly, it shouldn't matter, right?
.Sp
The other difference is that there is an additional data member in the object,
called \s-1HANDLER,\s0 which is for properly disposing of the handler when you are done
with it.  Your event handler should get disposed of for you in the background.
.Sp
An example:
.Sp
.Vb 7
\&        my @data_out;
\&        handle_event(\*(AqCLAS\*(Aq, \*(AqEVNT\*(Aq, \e&handler);
\&        sub handler {
\&                my($evt) = @_;
\&                my @data = $evt\->get;
\&                push @data_out, [$data[0], $data[9]] if $data[0] && $data[9];
\&        }
\&
\&        while (1) {
\&                if (my $data = shift @data_out) {
\&                        print "woohoo: @$data\en";
\&                }       
\&        }
.Ve
.ie n .IP "$EVENT\->data([\s-1KEY\s0])" 4
.el .IP "\f(CW$EVENT\fR\->data([\s-1KEY\s0])" 4
.IX Item "$EVENT->data([KEY])"
.PD 0
.ie n .IP "$EVENT\->get([\s-1KEY\s0])" 4
.el .IP "\f(CW$EVENT\fR\->get([\s-1KEY\s0])" 4
.IX Item "$EVENT->get([KEY])"
.IP "data(DESC[, \s-1KEY\s0])" 4
.IX Item "data(DESC[, KEY])"
.IP "get(DESC[, \s-1KEY\s0])" 4
.IX Item "get(DESC[, KEY])"
.PD
Similar to \f(CW\*(C`get\*(C'\fR and \f(CW\*(C`data\*(C'\fR from the Mac::AppleEvents module.
Get data from a Mac::AppleEvents::Simple object for a given key
(\f(CW\*(C`keyDirectObject\*(C'\fR is the default).  Can also be called as a function,
where an AEDesc object is passed as the first parameter.
.Sp
For \f(CW\*(C`data\*(C'\fR, if the descriptor in \s-1KEY\s0 is an \s-1AE\s0 list, then a list
of the descriptors in the list will be returned.  In scalar context,
only the first element will be returned.
.Sp
On the other hand, \f(CW\*(C`get\*(C'\fR will return a nested data structure,
where all nested \s-1AE\s0 lists will be converted to perl array references,
and all nested \s-1AE\s0 records will be converted to perl hash references.
In scalar context, only the first element of the base list will be
returned for \s-1AE\s0 lists.
.Sp
Also, \f(CW\*(C`get\*(C'\fR will attempt to convert other data into a more usable form
(such as resolving aliases into paths).
.IP "pack_ppc(\s-1ID, NAME,\s0 SERVER[, \s-1ZONE\s0])" 4
.IX Item "pack_ppc(ID, NAME, SERVER[, ZONE])"
\&\fBNote\fR: Not implemented under Mac \s-1OS X.\s0
.Sp
Packs a \s-1PPC\s0 record suitable for using in \f(CW\*(C`build_event\*(C'\fR and \f(CW\*(C`do_event\*(C'\fR.
Accepts the 4\-character \s-1ID\s0 of the target app, the name of the app as it
may appear in the \s-1PPC\s0 Chooser, and the server and zone it is on.  If
not supplied, zone is assumed to be '*'.
.IP "pack_eppc(\s-1ID, NAME, HOST\s0)" 4
.IX Item "pack_eppc(ID, NAME, HOST)"
\&\fBNote\fR: Not implemented under Mac \s-1OS X \s0(see pack_eppc_x).
.Sp
Packs an \s-1EPPC\s0 record suitable for using in \f(CW\*(C`build_event\*(C'\fR and \f(CW\*(C`do_event\*(C'\fR.
Accepts the 4\-character \s-1ID\s0 of the target app, the name of the app as it
may appear in the \s-1PPC\s0 Chooser, and the hostname of the machine it is on.
Requires Mac \s-1OS 9.\s0
.IP "pack_eppc_x(\s-1NAME, HOST\s0 [, \s-1UID, PID, USERNAME, PASSWORD\s0])" 4
.IX Item "pack_eppc_x(NAME, HOST [, UID, PID, USERNAME, PASSWORD])"
\&\fBNote\fR: Not implemented under Mac \s-1OS \s0(see pack_eppc).
.Sp
Packs an \s-1EPPC\s0 record suitable for using in \f(CW\*(C`build_event\*(C'\fR and \f(CW\*(C`do_event\*(C'\fR
under Mac \s-1OS X. \s0 Accepts the name of the app, the hostname of the machine
it is on, and, optionally, the uid of the owner of the app, the process \s-1ID\s0
of the app, and the username/password to connect with.  Note that it is
normally preferable to allow the Keychain to handle the username/password
(enter it the first time it is asked for, and select \*(L"Add to Keychain?\*(R").
Requires Mac \s-1OS X.\s0
.Sp
\&\fBNote\fR: the \s-1UID/PID\s0 stuff doesn't actually work for me, in my tests.  Huh.
.Sp
\&\fBNote\fR: the eppc port (for both Mac \s-1OS\s0 and Mac \s-1OS X\s0) is 3031.
.IP "pack_psn(\s-1PSN\s0)" 4
.IX Item "pack_psn(PSN)"
Simply packs a \s-1PSN\s0 into a double long.
.IP "pack_pid(\s-1PID\s0)" 4
.IX Item "pack_pid(PID)"
\&\fBNote\fR: Mac \s-1OS X\s0 only.
.Sp
Converts a \s-1PID\s0 into a \s-1PSN,\s0 then calls \f(CW\*(C`pack_psn\*(C'\fR.
.SH "EXPORT"
.IX Header "EXPORT"
Exports functions \f(CW\*(C`do_event\*(C'\fR, \f(CW\*(C`build_event\*(C'\fR, \f(CW\*(C`handle_event\*(C'\fR,
\&\f(CW\*(C`pack_ppc\*(C'\fR, \f(CW\*(C`pack_eppc\*(C'\fR, \f(CW\*(C`pack_psn\*(C'\fR, \f(CW\*(C`pack_pid\*(C'\fR.  All the symbols from
Mac::AppleEvents are available in \f(CW@EXPORT_OK\fR and through the
\&\f(CW\*(C`all\*(C'\fR export tag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Nandor <pudge@pobox.com>, http://pudge.net/
.PP
Copyright (c) 1998\-2005 Chris Nandor.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mac::AppleEvents, Mac::OSA, Mac::OSA::Simple, macperlcat, Inside Macintosh: 
Interapplication Communication.
.PP
.Vb 1
\&        http://projects.pudge.net/
.Ve
