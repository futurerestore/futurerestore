.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Memory 3"
.TH Memory 3 "2017-07-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Memory \- MacOS Memory Manager
.PP
Provide the MacPerl interface to the memory management routines in the MacOS.
.PP
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. You have been warned.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The Memory module defines Ptr and Handle classes, and function interfaces to the 
memory management.
.PP
.Vb 3
\&    use Mac::Memory;
\&    $handle = new Handle;
\&    $handle2 = NewHandle;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The following packages and functions provide low level access to the memory
management functions.
.SS "Handle"
.IX Subsection "Handle"
Handle provides an object interface to do simple operations on MacOS handles.
The interface is simpler than the more general memory management functions.
.IP "new" 4
.IX Item "new"
.PD 0
.IP "new \s-1STRING\s0" 4
.IX Item "new STRING"
.PD
Create a new handle and return it. Copy \f(CW$STRING\fR into the handle if present.
Return a 0 value if a handle could not be created.
.Sp
.Vb 2
\&    $h = new Handle;
\&    $hs = new Handle("This string will now exist in hyperspace");
.Ve
.IP "size" 4
.IX Item "size"
Return the size of a handle (i.e., its data portion).
.Sp
.Vb 2
\&    die unless (new Handle)\->size == 0;
\&    die unless $hs\->size == 40;
.Ve
.IP "append \s-1DATA \s0" 4
.IX Item "append DATA "
Appends the \s-1DATA\s0 to the end of the handle
and returns the success as the result.
.Sp
.Vb 2
\&    $h\->append("This string will now exist in hyperspace");
\&    die unless $h\->size == 40;
.Ve
.IP "set \s-1OFFSET, LENGTH, DATA \s0" 4
.IX Item "set OFFSET, LENGTH, DATA "
.PD 0
.IP "set \s-1OFFSET, LENGTH \s0" 4
.IX Item "set OFFSET, LENGTH "
.IP "set \s-1OFFSET \s0" 4
.IX Item "set OFFSET "
.IP "set" 4
.IX Item "set"
.PD
Munge the contents of the handle with the \f(CW$DATA\fR (deleting if not present), for the
\&\f(CW$LENGTH\fR (through to the end of the handle contents if not present), starting at
\&\f(CW$OFFSET\fR (the beginning if not present).
.Sp
.Vb 1
\&    $h\->set(5, 6, "datum");
.Ve
.Sp
yields
.Sp
.Vb 1
\&    "This datum will now exist in hyperspace"
.Ve
.IP "get \s-1OFFSET, LENGTH \s0" 4
.IX Item "get OFFSET, LENGTH "
.PD 0
.IP "get \s-1OFFSET \s0" 4
.IX Item "get OFFSET "
.IP "get" 4
.IX Item "get"
.PD
Return a datum which is the contents of the memory referenced by \f(CW$HANDLE\fR, 
starting at \f(CW$OFFSET\fR (default zero), of length \f(CW$LENGTH\fR (default the rest
of the handle).
.Sp
.Vb 1
\&    die unless $hs\->get(5, 6) eq "string";
.Ve
.IP "address" 4
.IX Item "address"
Return the address of the memory block.
.IP "state" 4
.IX Item "state"
.PD 0
.IP "state \s-1NEWSTATE \s0" 4
.IX Item "state NEWSTATE "
.PD
Return the (locked) state of the handle, or return \s-1TRUE\s0 if the \f(CW$NEWSTATE\fR
of the handle is installed.
.Sp
.Vb 4
\&    my $state = $h\->state;
\&    HLock($h);
\&    # bunch of operations requiring $h to be locked
\&    $h\->state($state);  # so nested locks exit properly
.Ve
.Sp
More than the lock state is stored here, so restoring the actual state on leaving
a scope is required.
.IP "open \s-1MODE\s0" 4
.IX Item "open MODE"
Open a stream to a handle and return it.
.Sp
\&\s-1NOT DEFINED AT THE MOMENT\s0
.Sp
SysRet
_open(hand, mode)
	Handle	hand
	int		mode
	\s-1CODE:
	RETVAL\s0 = OpenHandle(hand, mode);
	\s-1OUTPUT:
	RETVAL\s0
.IP "dispose" 4
.IX Item "dispose"
Disposes of the handle.
Return zero if no error was detected.
.PP
Almost all of the memory management needs in MacPerl can be handled by the above interface
.SS "Ptr"
.IX Subsection "Ptr"
Ptr provides an object interface to do simple operations on MacOS pointers
(nonrelocatable heap blocks). There are very few good reasons to create pointers
like this.
.IP "size" 4
.IX Item "size"
Return the size of a pointer (i.e., its data portion).
.Sp
.Vb 1
\&    die unless $ptr\->size == 40;
.Ve
.IP "set \s-1OFFSET, DATA \s0" 4
.IX Item "set OFFSET, DATA "
.PD 0
.IP "get \s-1OFFSET, LENGTH \s0" 4
.IX Item "get OFFSET, LENGTH "
.IP "get \s-1OFFSET \s0" 4
.IX Item "get OFFSET "
.IP "get" 4
.IX Item "get"
.PD
Return a datum which is the contents of the memory referenced by \s-1PTR, \s0
starting at \f(CW$OFFSET\fR (default zero), of length \f(CW$LENGTH\fR (default the rest
of the block).
.Sp
.Vb 1
\&    die unless $ps\->get(5, 6) eq "string";
.Ve
.IP "address" 4
.IX Item "address"
Return the address of the memory block.
.IP "dispose" 4
.IX Item "dispose"
Disposes of the block.
Return zero if no error was detected.
.SS "Functions"
.IX Subsection "Functions"
.IP "GetApplLimit" 4
.IX Item "GetApplLimit"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
The GetApplLimit function returns the current application heap limit.
.IP "TopMem" 4
.IX Item "TopMem"
Return a pointer to the top of memory for the application.
.IP "NewHandle \s-1BYTECOUNT\s0" 4
.IX Item "NewHandle BYTECOUNT"
.PD 0
.IP "NewHandleSys \s-1BYTECOUNT\s0" 4
.IX Item "NewHandleSys BYTECOUNT"
.IP "NewHandleClear \s-1BYTECOUNT\s0" 4
.IX Item "NewHandleClear BYTECOUNT"
.IP "NewHandleSysClear \s-1BYTECOUNT\s0" 4
.IX Item "NewHandleSysClear BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR (NewHandleSys, NewHandleSysClear)
.Sp
Return a handle of \f(CW$BYTECOUNT\fR size.
.Sp
NewHandleSys returns a handle in the system heap.
.Sp
The NewHandleClear and NewHandleSysClear functions work much as the NewHandle
and NewHandleSys functions do but set
all bytes in the new block to 0 instead of leaving the contents of the block
undefined.
Currently, this is quite inefficient.
.IP "NewPtr \s-1BYTECOUNT\s0" 4
.IX Item "NewPtr BYTECOUNT"
.PD 0
.IP "NewPtrSys \s-1BYTECOUNT\s0" 4
.IX Item "NewPtrSys BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR
.IP "NewPtrClear \s-1BYTECOUNT\s0" 4
.IX Item "NewPtrClear BYTECOUNT"
.PD 0
.IP "NewPtrSysClear \s-1BYTECOUNT\s0" 4
.IX Item "NewPtrSysClear BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR (NewPtrSys, NewPtrSysClear)
.Sp
Allocate a nonrelocatable block of memory of a specified size.
.Sp
NewPtrSys and NewPtrSysClear allocate blocks in the system heap.
.Sp
NewPtrClear and NewPtrSysClear allocate and zero the blocks (inefficiently).
.IP "MaxBlock" 4
.IX Item "MaxBlock"
.PD 0
.IP "MaxBlockSys" 4
.IX Item "MaxBlockSys"
.PD
\&\fBMac \s-1OS\s0 only.\fR (MaxBlockSys)
.Sp
The MaxBlock function returns the maximum contiguous space, in bytes, that you
could obtain after compacting the current heap zone. MaxBlock does not actually
do the compaction.
.Sp
MaxBlockSys does the same for the system heap.
.IP "StackSpace" 4
.IX Item "StackSpace"
The StackSpace function returns the current amount of stack space (in bytes)
between the current stack pointer and the application heap at the instant of
return from the trap.
.IP "NewEmptyHandle" 4
.IX Item "NewEmptyHandle"
.PD 0
.IP "NewEmptyHandleSys" 4
.IX Item "NewEmptyHandleSys"
.PD
\&\fBMac \s-1OS\s0 only.\fR (NewEmptyHandleSys)
.Sp
The NewEmptyHandle function initializes a new handle by allocating a master
pointer for it, but it does not allocate any memory for the handle to control.
NewEmptyHandle
sets the handle's master pointer to \s-1NIL.\s0
.Sp
NewEmptyHandleSys does the same for the system heap.
.IP "HLock \s-1HANDLE\s0" 4
.IX Item "HLock HANDLE"
Lock a relocatable block so that it does not move in the heap. If you plan to
dereference a handle and then allocate, move, or purge memory (or call a routine
that does so), then you should lock the handle before using the dereferenced
handle.
.IP "HUnlock \s-1HANDLE\s0" 4
.IX Item "HUnlock HANDLE"
Unlock a relocatable block so that it is free to move in its heap zone.
.IP "HPurge \s-1HANDLE\s0" 4
.IX Item "HPurge HANDLE"
Mark a relocatable block so that it can be purged if a memory request cannot be
fulfilled after compaction.
.IP "HNoPurge \s-1HANDLE\s0" 4
.IX Item "HNoPurge HANDLE"
Mark a relocatable block so that it cannot be purged.
.IP "HLockHi \s-1HANDLE\s0" 4
.IX Item "HLockHi HANDLE"
The HLockHi procedure attempts to move the relocatable block referenced by the
handle \f(CW$HANDLE\fR upward until it reaches a nonrelocatable block, a locked relocatable
block, or the top of the heap. Then HLockHi locks the block.
.IP "TempNewHandle \s-1BYTECOUNT\s0" 4
.IX Item "TempNewHandle BYTECOUNT"
The TempNewHandle function returns a handle to a block of size \f(CW$BYTECOUNT\fR from
temporary memory. If it
cannot allocate a block of that size, the function returns \s-1NIL.\s0
.IP "TempMaxMem" 4
.IX Item "TempMaxMem"
The TempMaxMem function compacts the current heap zone and returns the size of
the largest contiguous block available for temporary allocation.
.Sp
.Vb 1
\&    $SIZE = &TempMaxMem;
.Ve
.IP "TempFreeMem" 4
.IX Item "TempFreeMem"
The TempFreeMem function returns the total amount of free temporary memory that
you could allocate by calling TempNewHandle. The returned value is the total
number of free bytes. Because these bytes might be dispersed throughout memory,
it is ordinarily not possible to allocate a single relocatable block of that
size.
.Sp
.Vb 1
\&    $SIZE = &TempFreeMem;
.Ve
.IP "CompactMem \s-1BYTECOUNT\s0" 4
.IX Item "CompactMem BYTECOUNT"
.PD 0
.IP "CompactMemSys \s-1BYTECOUNT\s0" 4
.IX Item "CompactMemSys BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR (CompactMemSys)
.Sp
The CompactMem function compacts the current heap zone by moving unlocked,
relocatable blocks down until they encounter nonrelocatable blocks or locked,
relocatable blocks, but not by purging blocks. It continues compacting until it
either finds a contiguous block of at least \f(CW$BYTECOUNT\fR free bytes or has compacted
the entire zone.
.Sp
The CompactMem function returns the size, in bytes, of the largest contiguous
free block for which it could make room, but it does not actually allocate that
block.
.Sp
CompactMemSys does the same for the system heap.
.IP "PurgeMem \s-1BYTECOUNT\s0" 4
.IX Item "PurgeMem BYTECOUNT"
.PD 0
.IP "PurgeMemSys \s-1BYTECOUNT\s0" 4
.IX Item "PurgeMemSys BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR (PurgeMemSys)
.Sp
The PurgeMem procedure sequentially purges blocks from the current heap zone
until it either allocates a contiguous block of at least \f(CW$BYTECOUNT\fR free bytes or
has purged the entire zone. If it purges the entire zone without creating a
contiguous block of at least \f(CW$BYTECOUNT\fR free bytes, PurgeMem generates a
memFullErr.
.Sp
The PurgeMem procedure purges only relocatable, unlocked, purgeable blocks.
.Sp
The PurgeMem procedure does not actually attempt to allocate a block of  \f(CW$BYTECOUNT\fR
bytes.
.Sp
PurgeMemSys does the same for the system heap.
.IP "FreeMem" 4
.IX Item "FreeMem"
.PD 0
.IP "FreeMemSys" 4
.IX Item "FreeMemSys"
.PD
\&\fBMac \s-1OS\s0 only.\fR (FreeMemSys)
.Sp
The FreeMem function returns the total amount of free space (in bytes) in the
current heap zone. Note that it usually isn't possible to allocate a block of
that size, because of heap fragmentation due to nonrelocatable or locked blocks.
.Sp
FreeMemSys does the same for the system heap.
.IP "ReserveMem \s-1BYTECOUNT\s0" 4
.IX Item "ReserveMem BYTECOUNT"
.PD 0
.IP "ReserveMemSys \s-1BYTECOUNT\s0" 4
.IX Item "ReserveMemSys BYTECOUNT"
.PD
\&\fBMac \s-1OS\s0 only.\fR (ReserveMemSys)
.Sp
The ReserveMem procedure attempts to create free space for a block of \f(CW$BYTECOUNT\fR
contiguous logical bytes at the lowest possible position in the current heap
zone. It pursues every available means of placing the block as close as possible
to the bottom of the zone, including moving other relocatable blocks upward,
expanding the zone (if possible), and purging blocks from it.
.Sp
ReserveMemSys does the same for the system heap.
.IP "MaxMem" 4
.IX Item "MaxMem"
.PD 0
.IP "MaxMemSys" 4
.IX Item "MaxMemSys"
.PD
\&\fBMac \s-1OS\s0 only.\fR (MaxMemSys)
.Sp
Use the MaxMem function to compact and purge the current heap zone. The values
returned are the amount of memory available and the amount by which the zone can
grow.
.Sp
.Vb 1
\&    ($SIZE, $GROW) = &MaxMem;
.Ve
.Sp
MaxMemSys does the purge and compact of the system heap zone, and the \f(CW$GROW\fR value
is set to zero.
.IP "MoveHHi \s-1HANDLE\s0" 4
.IX Item "MoveHHi HANDLE"
The MoveHHi procedure attempts to move the relocatable block referenced by the
handle \f(CW$HANDLE\fR upward until it reaches a nonrelocatable block, a locked relocatable
block, or the top of the heap.
.IP "DisposePtr \s-1PTR\s0" 4
.IX Item "DisposePtr PTR"
Releases the memory occupied by the nonrelocatable block specified by \f(CW$PTR\fR.
.IP "GetPtrSize \s-1PTR\s0" 4
.IX Item "GetPtrSize PTR"
The GetPtrSize function returns the logical size, in bytes, of the nonrelocatable
block pointed to by \f(CW$PTR\fR.
.IP "SetPtrSize \s-1PTR, NEWSIZE\s0" 4
.IX Item "SetPtrSize PTR, NEWSIZE"
The SetPtrSize procedure attempts to change the logical size of the
nonrelocatable block pointed to by \f(CW$PTR\fR. The new logical size is specified by
\&\f(CW$NEWSIZE\fR.
Return zero if no error was detected.
.IP "DisposeHandle \s-1HANDLE\s0" 4
.IX Item "DisposeHandle HANDLE"
The DisposeHandle procedure releases the memory occupied by the relocatable block
whose handle is \f(CW$HANDLE\fR. It also frees the handle's master pointer for other uses.
.IP "SetHandleSize \s-1HANDLE, BYTECOUNT\s0" 4
.IX Item "SetHandleSize HANDLE, BYTECOUNT"
The SetHandleSize procedure attempts to change the logical size of the
relocatable block whose handle is \f(CW$HANDLE\fR. The new logical size is specified by
\&\f(CW$BYTECOUNT\fR.
Return zero if no error was detected.
.IP "GetHandleSize \s-1HANDLE\s0" 4
.IX Item "GetHandleSize HANDLE"
The GetHandleSize function returns the logical size, in bytes, of the relocatable
block whose handle is \f(CW$HANDLE\fR. In case of an error, GetHandleSize returns 0.
.IP "ReallocateHandle \s-1HANDLE, BYTECOUNT\s0" 4
.IX Item "ReallocateHandle HANDLE, BYTECOUNT"
Allocates a new relocatable block with a logical size of \f(CW$BYTECOUNT\fR bytes. It
updates the handle \f(CW$HANDLE\fR by setting its master pointer to point to the new block. 
The new block is unlocked and unpurgeable.
Return zero if no error was detected.
.IP "EmptyHandle" 4
.IX Item "EmptyHandle"
Free memory taken by a relocatable block without freeing the relocatable block's
master pointer for other uses.
.IP "MoreMasters" 4
.IX Item "MoreMasters"
Call the MoreMasters procedure several times at the beginning of your program to
prevent the Memory Manager from running out of master pointers in the middle of
application execution. If it does run out, it allocates more, possibly causing
heap fragmentation.
.IP "BlockMove \s-1SOURCEPTR, DESTPTR, BYTECOUNT\s0" 4
.IX Item "BlockMove SOURCEPTR, DESTPTR, BYTECOUNT"
.PD 0
.IP "BlockMoveData \s-1SOURCEPTR, DESTPTR, BYTECOUNT\s0" 4
.IX Item "BlockMoveData SOURCEPTR, DESTPTR, BYTECOUNT"
.PD
The BlockMove/BlockMoveData procedure moves a block of \f(CW$BYTECOUNT\fR consecutive bytes from the
address designated by \f(CW$SOURCEPTR\fR to that designated by \f(CW$DESTPTR\fR.
.IP "PurgeSpace" 4
.IX Item "PurgeSpace"
Determine the total amount of free memory and the size of the largest allocatable
block after a purge of the heap.
.Sp
.Vb 1
\&    ($Total, $Contiguous) = &PurgeSpace;
.Ve
.IP "HGetState \s-1HANDLE\s0" 4
.IX Item "HGetState HANDLE"
Get the current properties of a relocatable block (perhaps so that you can change
and then later restore those properties).
.IP "HSetState \s-1HANDLE, STATE\s0" 4
.IX Item "HSetState HANDLE, STATE"
Restore properties of a block after a call to HGetState.
.IP "HandToHand \s-1HANDLE\s0" 4
.IX Item "HandToHand HANDLE"
The HandToHand function attempts to copy the information in the relocatable block
to which \f(CW$HANDLE\fR is a handle.
Return \f(CW\*(C`undef\*(C'\fR if an error was detected.
.IP "PtrToHand \s-1PTR, BYTECOUNT\s0" 4
.IX Item "PtrToHand PTR, BYTECOUNT"
The PtrToHand function returns a newly created handle to a copy of
the number of bytes specified by \f(CW$BYTECOUNT\fR, beginning at the location
specified by \f(CW$PTR\fR.
Return \f(CW\*(C`undef\*(C'\fR if an error was detected.
.IP "PtrToXHand \s-1HANDLE, PTR, BYTECOUNT\s0" 4
.IX Item "PtrToXHand HANDLE, PTR, BYTECOUNT"
The PtrToXHand function makes the existing handle, specified by \f(CW$HANDLE\fR, a handle
to a copy of the number of bytes specified by \f(CW$BYTECOUNT\fR, beginning at
the location specified by \f(CW$PTR\fR.
Return \f(CW\*(C`undef\*(C'\fR if an error was detected.
.IP "HandAndHand \s-1AHNDLE, BHNDLE\s0" 4
.IX Item "HandAndHand AHNDLE, BHNDLE"
The HandAndHand function concatenates the information from the relocatable block
to which \f(CW$AHNDL\fR is a handle onto the end of the relocatable block to which \f(CW$BHNDL\fR
is a handle. The \f(CW$AHNDL\fR variable remains unchanged.
Return zero if no error was detected.
.IP "PtrAndHand \s-1PTR, HANDLE, BYTECOUNT\s0" 4
.IX Item "PtrAndHand PTR, HANDLE, BYTECOUNT"
The PtrAndHand function takes the number of bytes specified by \f(CW$BYTECOUNT\fR, 
beginning at the location specified by \f(CW$PTR\fR, and concatenates them
onto the end of the relocatable block to which \f(CW$HANDLE\fR is a handle.
.PP
The low level interface is not likely to be needed, except for the \fIHLock()\fR function.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>,
documentation by Bob Dalgleish <bob.dalgleish@sasknet.sk.ca>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
