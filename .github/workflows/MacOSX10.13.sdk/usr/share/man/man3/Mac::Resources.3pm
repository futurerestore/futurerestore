.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Resources 3"
.TH Resources 3 "2017-07-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::Resources \- Macintosh Toolbox Interface to the Resource Manager
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Mac::Memory;
\&    use Mac::Resources;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Constants"
.IX Subsection "Constants"
.IP "resSysHeap" 4
.IX Item "resSysHeap"
.PD 0
.IP "resPurgeable" 4
.IX Item "resPurgeable"
.IP "resLocked" 4
.IX Item "resLocked"
.IP "resProtected" 4
.IX Item "resProtected"
.IP "resPreload" 4
.IX Item "resPreload"
.IP "resChanged" 4
.IX Item "resChanged"
.PD
Resource flags.
.IP "mapReadOnly" 4
.IX Item "mapReadOnly"
.PD 0
.IP "mapCompact" 4
.IX Item "mapCompact"
.IP "mapChanged" 4
.IX Item "mapChanged"
.PD
Resource map flags.
.IP "kResFileNotOpened" 4
.IX Item "kResFileNotOpened"
Returned after an unsuccessful call to \f(CW\*(C`OpenResFile()\*(C'\fR.
.IP "kSystemResFile" 4
.IX Item "kSystemResFile"
The resource file reference number of the system file.
.SS "Functions"
.IX Subsection "Functions"
.IP "CloseResFile \s-1RFD\s0" 4
.IX Item "CloseResFile RFD"
Given a file reference number for a file whose resource fork is open, the
CloseResFile procedure performs four tasks. First, it updates the file by calling
the &UpdateResFile procedure. Second, it releases the memory occupied by each
resource in the resource fork by calling the &DisposeHandle procedure. Third, it
releases the memory occupied by the resource map. The fourth task is to close the
resource fork.
.IP "CurResFile" 4
.IX Item "CurResFile"
The CurResFile function returns the file reference number associated with the
current resource file. You can call this function when your application starts up
(before opening the resource fork of any other file) to get the file reference
number of your application's resource fork.
.Sp
.Vb 1
\&    $RFD = CurResFile;
.Ve
.IP "HomeResFile \s-1RESOURCE\s0" 4
.IX Item "HomeResFile RESOURCE"
Given a handle to a resource, the HomeResFile function returns the file reference
number for the resource fork containing the specified resource. If the given
handle isn't a handle to a resource, HomeResFile returns \*(D-1, and the &ResError
function returns the result code resNotFound. If HomeResFile returns 0, the
resource is in the System file's resource fork. If HomeResFile returns 1, the
resource is ROM-resident.
.Sp
.Vb 1
\&    $RFD = HomeResFile($Resource);
.Ve
.IP "CreateResFile \s-1NAME\s0" 4
.IX Item "CreateResFile NAME"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
The CreateResFile procedure creates an empty resource file.
.Sp
.Vb 5
\&    if ( CreateResFile("Resource.rsrc")) {
\&        # error occurred
\&    } else {
\&        # proceed
\&    }
.Ve
.IP "OpenResFile \s-1NAME\s0" 4
.IX Item "OpenResFile NAME"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
The OpenResFile function opens an existing resource file. It also makes this file
the current resource file.
.Sp
.Vb 5
\&    if ( defined($RFD = OpenResFile("Resource.rsrc")) ) {
\&        # proceed
\&    } else {
\&        # error occurred
\&    }
.Ve
.IP "UseResFile \s-1RFD\s0" 4
.IX Item "UseResFile RFD"
The UseResFile procedure searches the list of files whose resource forks have
been opened for the file specified by the \s-1RFD\s0 parameter. If the specified file
is found, the Resource Manager sets the current resource file to the specified
file. If there's no resource fork open for a file with that reference number,
UseResFile does nothing. To set the current resource file to the System file, use
0 for the refNum parameter.
.Sp
.Vb 5
\&    if (UseResFile($RFD)) {
\&        # error occurred
\&    } else {
\&        # proceed
\&    }
.Ve
.IP "CountTypes" 4
.IX Item "CountTypes"
.PD 0
.IP "Count1Types" 4
.IX Item "Count1Types"
.PD
The CountTypes (Count1Types) function reads the resource maps in memory for all resource forks
(the current resource fork) open to your application. It returns an integer representing the 
total number of unique resource types.
.Sp
.Vb 1
\&    $types = Count1Types;
.Ve
.IP "GetIndType \s-1INDEX\s0" 4
.IX Item "GetIndType INDEX"
.PD 0
.IP "Get1IndType \s-1INDEX\s0" 4
.IX Item "Get1IndType INDEX"
.PD
Given an index number from 1 to the number of resource types in all resource
forks (the current resource fork)
open to your application (as returned by CountTypes), the GetIndType
procedure returns a resource type. You can call
GetIndType repeatedly over the entire range of the index to get all the resource
types available in all resource forks open to your application. If the given
index isn't in the range from 1 to the number of resource types as returned by
CountTypes, \fIundef()\fR is returned.
.Sp
.Vb 4
\&    # Load up @resourceTypes with the types from the current file.
\&    for (1 .. Count1Types) {
\&        $resourceTypes[$_\-1] = Get1IndType($_);
\&    }
.Ve
.IP "SetResLoad \s-1BOOL\s0" 4
.IX Item "SetResLoad BOOL"
Enable and disable automatic loading of resource data into memory for routines
that return handles to resources.
.IP "CountResources \s-1TYPE\s0" 4
.IX Item "CountResources TYPE"
.PD 0
.IP "Count1Resources \s-1TYPE\s0" 4
.IX Item "Count1Resources TYPE"
.PD
Get the total number of available resources of a given type. Count1Resources
looks only at the current resource fork.
.Sp
.Vb 1
\&    $totalDialogsAvailable = CountResources "DITL";
.Ve
.IP "GetIndResource \s-1TYPE, INDEX\s0" 4
.IX Item "GetIndResource TYPE, INDEX"
.PD 0
.IP "Get1IndResource \s-1TYPE, INDEX\s0" 4
.IX Item "Get1IndResource TYPE, INDEX"
.PD
Given an index ranging from 1 to the number of resources of a given type returned
by &CountResources (&Count1Resources) (that is, the number of resources of that type 
in all resource forks open to your application), the GetIndResource function returns a 
handle to a resource of the given type. If you call GetIndResource repeatedly over the
entire range of the index, it returns handles to all resources of the given type
in all resource forks open to your application.
.Sp
.Vb 4
\&    # Load up handles of this type of resource
\&    for (1 .. CountResources("DITL")) {
\&        $dialogs[$_] = GetIndResource("DITL", $_);
\&    }
.Ve
.IP "GetResource \s-1TYPE, ID\s0" 4
.IX Item "GetResource TYPE, ID"
.PD 0
.IP "Get1Resource \s-1TYPE, ID\s0" 4
.IX Item "Get1Resource TYPE, ID"
.PD
Get resource data for a resource specified by resource type and resource \s-1ID.\s0
.Sp
.Vb 4
\&    $SFGdialog = GetResource("DITL", 6042);
\&    if ( defined $SFGdialog ) {
\&        # proceed
\&    }
.Ve
.IP "GetNamedResource \s-1TYPE, NAME\s0" 4
.IX Item "GetNamedResource TYPE, NAME"
.PD 0
.IP "Get1NamedResource \s-1TYPE, NAME\s0" 4
.IX Item "Get1NamedResource TYPE, NAME"
.PD
The GetNamedResource (Get1NamedResource) function searches the resource maps in memory for the
resource specified by the parameters \f(CW$TYPE\fR and \f(CW$NAME\fR.
.Sp
.Vb 4
\&    $SFGdialog = GetNamedResource("DITL", "Standard Get");
\&    if ( defined $SFGdialog ) {
\&        # proceed
\&    }
.Ve
.IP "LoadResource \s-1HANDLE\s0" 4
.IX Item "LoadResource HANDLE"
Given a handle to a resource, LoadResource reads the resource data into memory.
If the \s-1HANDLE\s0 parameter doesn't contain a handle to a resource, then LoadResource
returns undef.
.Sp
.Vb 5
\&    if (LoadResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error occurred
\&    }
.Ve
.IP "ReleaseResource \s-1HANDLE\s0" 4
.IX Item "ReleaseResource HANDLE"
Given a handle to a resource, ReleaseResource releases the memory occupied by the
resource data, if any, and sets the master pointer of the resource's handle in
the resource map in memory to \s-1NIL.\s0 If your application previously obtained a
handle to that resource, the handle is no longer valid. If your application
subsequently calls the Resource Manager to get the released resource, the
Resource Manager assigns a new handle.
.Sp
.Vb 5
\&    if ( ReleaseResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error occurred
\&    }
.Ve
.IP "DetachResource \s-1HANDLE\s0" 4
.IX Item "DetachResource HANDLE"
Given a handle to a resource, ReleaseResource releases the memory occupied by the
resource data, if any, and sets the master pointer of the resource's handle in
the resource map in memory to \s-1NIL.\s0 If your application previously obtained a
handle to that resource, the handle is no longer valid. If your application
subsequently calls the Resource Manager to get the released resource, the
Resource Manager assigns a new handle.
.Sp
.Vb 5
\&    if ( DetachResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error occurred
\&    }
.Ve
.IP "UniqueID \s-1TYPE\s0" 4
.IX Item "UniqueID TYPE"
.PD 0
.IP "Unique1ID \s-1TYPE\s0" 4
.IX Item "Unique1ID TYPE"
.PD
The UniqueID function returns as its function result a resource \s-1ID\s0 greater than 0
that isn't currently assigned to any resource of the specified type in any open
resource fork. You should use this function before adding a new resource to
ensure that you don't duplicate a resource \s-1ID\s0 and override an existing resource.
Unique1ID ensures uniqueness within the current resource fork.
.Sp
.Vb 1
\&    $id = Unique1ID("DITL");
.Ve
.IP "GetResAttrs \s-1HANDLE\s0" 4
.IX Item "GetResAttrs HANDLE"
Given a handle to a resource, the GetResAttrs function returns the resource's
attributes as recorded in its entry in the resource map in memory. If the value
of the theResource parameter isn't a handle to a valid resource, undef is returned.
.Sp
.Vb 4
\&    $resAttrs = GetResAttrs($HANDLE);
\&    if ( defined $resAttrs ) {
\&        # proceed
\&    }
.Ve
.IP "GetResInfo \s-1HANDLE\s0" 4
.IX Item "GetResInfo HANDLE"
Given a handle to a resource, the GetResInfo procedure returns the resource's
resource \s-1ID,\s0 resource type, and resource name. If the handle isn't a valid handle
to a resource, undef is returned.
.Sp
.Vb 4
\&    ($id, $type, $name) = GetResInfo($HANDLE);
\&    if ( defined $id ) {
\&        # proceed
\&    }
.Ve
.IP "SetResInfo \s-1HANDLE, ID, NAME\s0" 4
.IX Item "SetResInfo HANDLE, ID, NAME"
Given a handle to a resource, SetResInfo changes the resource \s-1ID\s0 and the resource
name of the specified resource to the values given in \s-1ID\s0 and \s-1NAME.\s0 If you pass
an empty string for the name parameter, the resource name is not changed.
.IP "AddResource \s-1HANDLE, TYPE, ID, NAME\s0" 4
.IX Item "AddResource HANDLE, TYPE, ID, NAME"
Given a handle to any type of data in memory (but not a handle to an existing
resource), AddResource adds the given handle, resource type, resource \s-1ID,\s0 and
resource name to the current resource file's resource map in memory. The
AddResource procedure sets the resChanged attribute to 1; it does not set any of
the resource's other attributesN\*~that is, all other attributes are set to 0.
.IP "GetResourceSizeOnDisk \s-1HANDLE\s0" 4
.IX Item "GetResourceSizeOnDisk HANDLE"
Given a handle to a resource, the GetResourceSizeOnDisk function checks the
resource on disk (not in memory) and returns its exact size, in bytes. If the
handle isn't a handle to a valid resource, undef is returned.
.Sp
.Vb 4
\&        $size = GetResourceSizeOnDisk($HANDLE);
\&        if ( defined $size ) {
\&                # proceed
\&        }
.Ve
.IP "GetMaxResourceSize \s-1HANDLE\s0" 4
.IX Item "GetMaxResourceSize HANDLE"
Like &GetResourceSizeOnDisk, GetMaxResourceSize takes a handle and returns the
size of the corresponding resource. However, GetMaxResourceSize does not check
the resource on disk; instead, it either checks the resource size in memory or,
if the resource is not in memory, calculates its size, in bytes, on the basis of
information in the resource map in memory. This gives you an approximate size for
the resource that you can count on as the resource's maximum size. It's possible
that the resource is actually smaller than the offsets in the resource map
indicate because the file has not yet been compacted. If you want the exact size
of a resource on disk, either call &GetResourceSizeOnDisk or call &UpdateResFile
before calling GetMaxResourceSize.
.Sp
.Vb 4
\&    $size = GetMaxResourceSize($HANDLE);
\&    if ( defined $size ) {
\&        # proceed
\&    }
.Ve
.IP "RsrcMapEntry \s-1HANDLE\s0" 4
.IX Item "RsrcMapEntry HANDLE"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Given a handle to a resource, RsrcMapEntry returns the offset of the specified
resource's entry from the beginning of the resource map in memory. If it doesn't
find the resource entry, RsrcMapEntry returns 0, and the ResError function
returns the result code resNotFound. If you pass a handle whose value is \s-1NIL,\s0
RsrcMapEntry returns arbitrary data.
.Sp
.Vb 4
\&    $offset = RsrcMapEntry($HANDLE);
\&    if ( defined $offset ) {
\&        # proceed
\&    }
.Ve
.IP "SetResAttrs \s-1HANDLE, ATTRS\s0" 4
.IX Item "SetResAttrs HANDLE, ATTRS"
Given a handle to a resource, SetResAttrs changes the resource attributes of the
resource to those specified in the attrs parameter. The SetResAttrs procedure
changes the information in the resource map in memory, not in the file on disk.
The resProtected attribute changes immediately. Other attribute changes take
effect the next time the specified resource is read into memory but are not made
permanent until the Resource Manager updates the resource fork.
.Sp
.Vb 5
\&    if ( SetResAttrs($HANDLE, $ATTRS) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "ChangedResource \s-1HANDLE\s0" 4
.IX Item "ChangedResource HANDLE"
Given a handle to a resource, the ChangedResource procedure sets the resChanged
attribute for that resource in the resource map in memory. If the resChanged
attribute for a resource has been set and your application calls &UpdateResFile or
quits, the Resource Manager writes the resource data for that resource (and for
all other resources whose resChanged attribute is set) and the entire resource
map to the resource fork of the corresponding file on disk. If the resChanged
attribute for a resource has been set and your application calls &WriteResource,
the Resource Manager writes only the resource data for that resource to disk.
.Sp
.Vb 5
\&    if ( ChangedResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "RemoveResource \s-1HANDLE\s0" 4
.IX Item "RemoveResource HANDLE"
Given a handle to a resource in the current resource file, RemoveResource removes
the resource entry (resource type, resource \s-1ID,\s0 resource name, if any, and
resource attributes) from the current resource file's resource map in memory.
.Sp
.Vb 5
\&    if ( RemoveResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "UpdateResFile \s-1RFD\s0" 4
.IX Item "UpdateResFile RFD"
Given the reference number of a file whose resource fork is open, UpdateResFile
performs three tasks. The first task is to change, add, or remove resource data
in the file's resource fork to match the resource map in memory. Changed resource
data for each resource is written only if that resource's resChanged bit has been
set by a successful call to &ChangedResource or &AddResource. The UpdateResFile
procedure calls the &WriteResource procedure to write changed or added resources
to the resource fork.
.Sp
.Vb 5
\&    if ( UpdateResFile($RFD) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "WriteResource \s-1HANDLE\s0" 4
.IX Item "WriteResource HANDLE"
Given a handle to a resource, WriteResource checks the resChanged attribute of
that resource. If the resChanged attribute is set to 1 (after a successful call
to the &ChangedResource or &AddResource procedure), WriteResource writes the
resource data in memory to the resource fork, then clears the resChanged
attribute in the resource's resource map in memory.
.Sp
.Vb 5
\&    if ( WriteResource($HANDLE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "SetResPurge \s-1INSTALL\s0" 4
.IX Item "SetResPurge INSTALL"
Specify \s-1TRUE\s0 in the install parameter to make the Memory Manager pass the handle
for a resource to the Resource Manager before purging the resource data to which
the handle points. The Resource Manager determines whether the handle points to a
resource in the application heap. It also checks if the resource's resChanged
attribute is set to 1. If these two conditions are met, the Resource Manager
calls the &WriteResource procedure to write the resource's resource data to the
resource fork before returning control to the Memory Manager.
.Sp
Specify \s-1FALSE\s0 in the install parameter to restore the normal state, so that the
Memory Manager purges resource data when it needs to without calling the Resource
Manager.
.Sp
.Vb 5
\&    if ( SetResPurge(1) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "GetResFileAttrs \s-1RFD\s0" 4
.IX Item "GetResFileAttrs RFD"
Given a file reference number, the GetResFileAttrs function returns the
attributes of the file's resource fork. Specify 0 in \f(CW$RFD\fR to get
the attributes of the System file's resource fork. If there's no open resource
fork for the given file reference number, undef is returned.
.Sp
.Vb 4
\&    $rfa = GetResFileAttrs($RFD);
\&    if ( defined $rfa ) {
\&        # proceed
\&    }
.Ve
.IP "SetResFileAttrs \s-1RFD, ATTRS\s0" 4
.IX Item "SetResFileAttrs RFD, ATTRS"
Given a file reference number, the SetResFileAttrs procedure sets the attributes
of the file's resource fork to those specified in the attrs parameter. If the
refNum parameter is 0, it represents the System file's resource fork. However,
you shouldn't change the attributes of the System file's resource fork. If
there's no resource fork with the given reference number, SetResFileAttrs does
nothing, and the ResError function returns the result code noErr.
.Sp
.Vb 5
\&    if ( SetResFileAttrs($RFD, $ATTRS) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "RGetResource \s-1TYPE, ID\s0" 4
.IX Item "RGetResource TYPE, ID"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
The RGetResource function searches the resource maps in memory for the resource
specified by the parameters \f(CW$TYPE\fR and \f(CW$ID\fR. The resource maps in memory, which
represent all open resource forks, are arranged as a linked list. The
RGetResource function first uses GetResource to search this list. The GetResource
function starts with the current resource file and progresses through the list in
order (that is, in reverse chronological order in which the resource forks were
opened) until it finds the resource's entry in one of the resource maps. If
GetResource doesn't find the specified resource in its search of the resource
maps of open resource forks (which includes the System file's resource fork),
RGetResource sets the global variable RomMapInsert to \s-1TRUE,\s0 then calls
GetResource again. In response, GetResource performs the same search, but this
time it looks in the resource map of the ROM-resident resources before searching
the resource map of the System file.
.Sp
.Vb 4
\&    $handle = RGetResource("DITL", 6042);
\&    if ( defined $handle ) {
\&        # proceed
\&    }
.Ve
.IP "FSpOpenResFile \s-1SPEC, PERMISSION\s0" 4
.IX Item "FSpOpenResFile SPEC, PERMISSION"
The FSpOpenResFile function opens the resource fork of the file identified by the
spec parameter. It also makes this file the current resource file.
.Sp
.Vb 4
\&    $sp = FSpOpenResFile($SPEC);
\&    if ( defined $sp ) {
\&        # proceed
\&    }
.Ve
.Sp
In addition to opening the resource fork for the file with the specified name,
FSpOpenResFile lets you specify in the permission parameter the read/write permission
of the resource fork the first time it is opened.
.IP "FSOpenResourceFile \s-1REF, FORKNAME, PERMISSION\s0" 4
.IX Item "FSOpenResourceFile REF, FORKNAME, PERMISSION"
\&\fBMac \s-1OS X\s0 only.\fR
.Sp
The FSOpenResourceFile function is like FSpOpenResFile, except that it can open
a resource file using the data fork or resource fork.  \f(CW$REF\fR is the
path to the resource file.  \f(CW$FORKNAME\fR is
\&\*(L"rsrc\*(R" for a resource fork; else the data fork will be used.  It also makes this
file the current resource file.
.IP "FSpCreateResFile \s-1SPEC, CREATOR, FILETYPE, SCRIPTTAG\s0" 4
.IX Item "FSpCreateResFile SPEC, CREATOR, FILETYPE, SCRIPTTAG"
The FSpCreateResFile procedure creates an empty resource fork for a file with the
specified \f(CW$FILETYPE\fR, \f(CW$CREATOR\fR, and \f(CW$SCRIPTTAG\fR in the location and with the name
designated by the spec parameter. (An empty resource fork contains no resource
data but does include a resource map.)
.Sp
.Vb 5
\&    if ( FSpCreateResFile($SPEC, $CREATOR, $FILETYPE, $SCRIPTTAG) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "FSCreateResourceFile \s-1PARENTREF, FILENAME, FORKNAME\s0" 4
.IX Item "FSCreateResourceFile PARENTREF, FILENAME, FORKNAME"
\&\fBMac \s-1OS X\s0 only.\fR
.Sp
The FSCreateResourceFile procedure is like FSpCreateResFile, except that it can
create a resource file in the data fork or resource fork.  \f(CW$PARENTREF\fR is the
oath of the directory where the new \f(CW$FILENAME\fR will be located.  \f(CW$FORKNAME\fR is
\&\*(L"rsrc\*(R" for a resource fork; else the data fork will be used.
.IP "ReadPartialResource \s-1HANDLE, OFFSET, BYTECOUNT\s0" 4
.IX Item "ReadPartialResource HANDLE, OFFSET, BYTECOUNT"
The ReadPartialResource procedure reads the resource subsection identified by the
theResource, offset, and count parameters.
.Sp
.Vb 1
\&    $data = ReadPartialResource($rsrc, 2000, 256);
.Ve
.IP "WritePartialResource \s-1HANDLE, OFFSET, DATA\s0" 4
.IX Item "WritePartialResource HANDLE, OFFSET, DATA"
The WritePartialResource procedure writes the data specified by \s-1DATA \s0
to the resource subsection identified by the \s-1HANDLE\s0 and \s-1OFFSET\s0 parameters.
.Sp
.Vb 5
\&    if ( WritePartialResource($HANDLE, $OFFSET, $DATA) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.IP "SetResourceSize \s-1HANDLE, SIZE\s0" 4
.IX Item "SetResourceSize HANDLE, SIZE"
Given a handle to a resource, SetResourceSize sets the size field of the
specified resource on disk without writing the resource data. You can change the
size of any resource, regardless of the amount of memory you have available.
.Sp
.Vb 5
\&    if ( SetResource($HANDLE, $SIZE) ) {
\&        # proceed
\&    } else {
\&        # error
\&    }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>,
documentation by Bob Dalgleish <bob.dalgleish@sasknet.sk.ca>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 79:" 4
.IX Item "Around line 79:"
Non-ASCII character seen before =encoding in '\*(D-1,'. Assuming \s-1ISO8859\-1\s0
