.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Apache::TestSmoke 3"
.TH Apache::TestSmoke 3 "2015-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Apache::TestSmoke \- Special Tests Sequence Failure Finder
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # get the usage and the default values
\&  % t/SMOKE \-help
\&
\&  # repeat all tests 5 times and save the report into
\&  # the file \*(Aqmyreport\*(Aq
\&  % t/SMOKE \-times=5 \-report=myreport
\&
\&  # run all tests default number of iterations, and repeat tests
\&  # default number of times
\&  % t/SMOKE
\&
\&  # same as above but work only the specified tests
\&  % t/SMOKE foo/bar foo/tar
\&
\&  # run once a sequence of tests in a non\-random mode
\&  # e.g. when trying to reduce a known long sequence that fails
\&  % t/SMOKE \-order=rotate \-times=1 foo/bar foo/tar
\&
\&  # show me each currently running test
\&  # it\*(Aqs not the same as running the tests in the verbose mode
\&  % t/SMOKE \-verbose
\&
\&  # run t/TEST, but show any problems after *each* tests is run
\&  # useful for bug reports (it actually runs t/TEST \-start, then
\&  # t/TEST \-run for each test separately and finally t/TEST \-stop
\&  % t/SMOKE \-bug_mode
\&
\&  # now read the created report file
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "The Problem"
.IX Subsection "The Problem"
When we try to test a stateless machine (i.e. all tests are
independent), running all tests once ensures that all tested things
properly work. However when a state machine is tested (i.e. where a
run of one test may influence another test) it's not enough to run all
the tests once to know that the tested features actually work. It's
quite possible that if the same tests are run in a different order
and/or repeated a few times, some tests may fail.  This usually
happens when some tests don't restore the system under test to its
pristine state at the end of the run, which may influence other tests
which rely on the fact that they start on pristine state, when in fact
it's not true anymore. In fact it's possible that a single test may
fail when run twice or three times in a sequence.
.SS "The Solution"
.IX Subsection "The Solution"
To reduce the possibility of such dependency errors, it's helpful to
run random testing repeated many times with many different srand
seeds. Of course if no failures get spotted that doesn't mean that
there are no tests inter-dependencies, which may cause a failure in
production. But random testing definitely helps to spot many problems
and can give better test coverage.
.SS "Resolving Sequence Problems"
.IX Subsection "Resolving Sequence Problems"
When this kind of testing is used and a failure is detected there are
two problems:
.IP "1." 4
First is to be able to reproduce the problem so if we think we fixed
it, we could verify the fix. This one is easy, just remember the
sequence of tests run till the failed test and rerun the same sequence
once again after the problem has been fixed.
.IP "2." 4
Second is to be able to understand the cause of the problem. If during
the random test the failure has happened after running 400 tests, how
can we possibly know which previously running tests has caused to the
failure of the test 401. Chances are that most of the tests were clean
and don't have inter-dependency problem. Therefore it'd be very
helpful if we could reduce the long sequence to a minimum. Preferably
1 or 2 tests. That's when we can try to understand the cause of the
detected problem.
.PP
This utility attempts to solve both problems, and at the end of each
iteration print a minimal sequence of tests causing to a failure. This
doesn't always succeed, but works in many cases.
.PP
This utility:
.IP "1." 4
Runs the tests randomly until the first failure is detected. Or
non-randomly if the option \fI\-order\fR is set to \fIrepeat\fR or \fIrotate\fR.
.IP "2." 4
Then it tries to reduce that sequence of tests to a minimum, and this
sequence still causes to the same failure.
.IP "3." 4
(\s-1XXX:\s0 todo): then it reruns the minimal sequence in the verbose mode
and saves the output.
.IP "4." 4
It reports all the successful reductions as it goes to \s-1STDOUT\s0 and
report file of the format: smoke\-report\-<date>.txt.
.Sp
In addition the systems build parameters are logged into the report
file, so the detected problems could be reproduced.
.IP "5." 4
Goto 1 and run again using a new random seed, which potentially should
detect different failures.
.SH "Reduction Algorithm"
.IX Header "Reduction Algorithm"
Currently for each reduction path, the following reduction algorithms
get applied:
.IP "1." 4
Binary search: first try the upper half then the lower.
.IP "2." 4
Random window: randomize the left item, then the right item and return
the items between these two points.
.SH "t/SMOKE.PL"
.IX Header "t/SMOKE.PL"
\&\fIt/SMOKE.PL\fR is driving this module, if you don't have it, create it:
.PP
.Vb 1
\&  #!perl
\&
\&  use strict;
\&  use warnings FATAL => \*(Aqall\*(Aq;
\&
\&  use FindBin;
\&  use lib "$FindBin::Bin/../Apache\-Test/lib";
\&  use lib "$FindBin::Bin/../lib";
\&
\&  use Apache::TestSmoke ();
\&
\&  Apache::TestSmoke\->new(@ARGV)\->run;
.Ve
.PP
usually \fIMakefile.PL\fR converts it into \fIt/SMOKE\fR while adjusting the
perl path, but you create \fIt/SMOKE\fR in first place as well.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stas Bekman
