.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AppleEvents 3"
.TH AppleEvents 3 "2017-07-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::AppleEvents \- Macintosh Toolbox Interface to the Apple Event Manager
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Mac::AppleEvents;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Access to Inside Macintosh is essential for proper use of these functions.
Explanations of terms, processes and procedures are provided there.
Any attempt to use these functions without guidance can cause severe errors in 
your machine, including corruption of data. \fBYou have been warned.\fR
.SS "Constants: Apple event Descriptor Types"
.IX Subsection "Constants: Apple event Descriptor Types"
.IP "typeBoolean" 4
.IX Item "typeBoolean"
A boolean.
.IP "typeTrue" 4
.IX Item "typeTrue"
A boolean True value.
.IP "typeFalse" 4
.IX Item "typeFalse"
A boolean False value.
.IP "typeChar" 4
.IX Item "typeChar"
A string.
.IP "typeShortInteger" 4
.IX Item "typeShortInteger"
A 16 bit integer.
.IP "typeInteger" 4
.IX Item "typeInteger"
.PD 0
.IP "typeLongInteger" 4
.IX Item "typeLongInteger"
.PD
A 32 bit integer.
.IP "typeMagnitude" 4
.IX Item "typeMagnitude"
An unsigned 32 bit integer.
.IP "typeShortFloat" 4
.IX Item "typeShortFloat"
A single precision floating point number.
.IP "typeFloat" 4
.IX Item "typeFloat"
.PD 0
.IP "typeLongFloat" 4
.IX Item "typeLongFloat"
.PD
A double precision floating point number.
.IP "typeExtended" 4
.IX Item "typeExtended"
An extended double precision floating point number.
.IP "typeComp" 4
.IX Item "typeComp"
A 64 bit number.
.IP "typeAEList" 4
.IX Item "typeAEList"
An Apple event list.
.IP "typeAERecord" 4
.IX Item "typeAERecord"
An Apple event record.
.IP "typeAppleEvent" 4
.IX Item "typeAppleEvent"
An Apple event.
.IP "typeFSS" 4
.IX Item "typeFSS"
A file specification record.
.IP "typeAlias" 4
.IX Item "typeAlias"
A file alias record.
.IP "typeEnumerated" 4
.IX Item "typeEnumerated"
An enumeration literal (4 byte character).
.IP "typeType" 4
.IX Item "typeType"
An Apple event type (4 byte character).
.IP "typeAppParameters" 4
.IX Item "typeAppParameters"
An application launch parameter record.
.IP "typeProperty" 4
.IX Item "typeProperty"
A property keyword (4 byte character).
.IP "typeKeyword" 4
.IX Item "typeKeyword"
A keyword (4 byte character).
.IP "typeSectionH" 4
.IX Item "typeSectionH"
An Edition Manager section handle.
.IP "typeWildCard" 4
.IX Item "typeWildCard"
An arbitrary value.
.IP "typeApplSignature" 4
.IX Item "typeApplSignature"
An application signature (4 byte character).
.IP "typeQDRectangle" 4
.IX Item "typeQDRectangle"
A QuickDraw rectangle.
.IP "typeFixed" 4
.IX Item "typeFixed"
A fixed point value.
.IP "typeSessionID" 4
.IX Item "typeSessionID"
A \s-1PPC\s0 Toolbox session \s-1ID.\s0
.IP "typeTargetID" 4
.IX Item "typeTargetID"
A target \s-1ID\s0 record.
.IP "typeProcessSerialNumber" 4
.IX Item "typeProcessSerialNumber"
A process serial number.
.IP "typeNull" 4
.IX Item "typeNull"
No data.
.SS "Constants: Parameter and Attribute Keywords"
.IX Subsection "Constants: Parameter and Attribute Keywords"
.IP "keyDirectObject" 4
.IX Item "keyDirectObject"
The direct object parameter.
.IP "keyErrorNumber" 4
.IX Item "keyErrorNumber"
Error number.
.IP "keyErrorString" 4
.IX Item "keyErrorString"
Error string.
.IP "keyProcessSerialNumber" 4
.IX Item "keyProcessSerialNumber"
Process serial number.
.IP "keyTransactionIDAttr" 4
.IX Item "keyTransactionIDAttr"
Transaction \s-1ID.\s0
.IP "keyReturnIDAttr" 4
.IX Item "keyReturnIDAttr"
Return \s-1ID.\s0
.IP "keyEventClassAttr" 4
.IX Item "keyEventClassAttr"
Event class.
.IP "keyEventIDAttr" 4
.IX Item "keyEventIDAttr"
Event \s-1ID.\s0
.IP "keyAddressAttr" 4
.IX Item "keyAddressAttr"
Destination address.
.IP "keyOptionalKeywordAttr" 4
.IX Item "keyOptionalKeywordAttr"
List of optional keywords.
.IP "keyTimeoutAttr" 4
.IX Item "keyTimeoutAttr"
Timeout limit.
.IP "keyInteractLevelAttr" 4
.IX Item "keyInteractLevelAttr"
Interaction level.
.IP "keyEventSourceAttr" 4
.IX Item "keyEventSourceAttr"
Event source address.
.IP "keyMissedKeywordAttr" 4
.IX Item "keyMissedKeywordAttr"
List of mandatory keywords not used.
.IP "keyOriginalAddressAttr" 4
.IX Item "keyOriginalAddressAttr"
Original source address.
.IP "keyPreDispatch" 4
.IX Item "keyPreDispatch"
Install handler before dispatching.
.IP "keySelectProc" 4
.IX Item "keySelectProc"
Enable/Disable \s-1OSL.\s0
.IP "keyAERecorderCount" 4
.IX Item "keyAERecorderCount"
Number of processes recording AppleEvents.
.IP "keyAEVersion" 4
.IX Item "keyAEVersion"
Apple Event Manager version.
.SS "Constants: Core Apple event Suite"
.IX Subsection "Constants: Core Apple event Suite"
.IP "kCoreEventClass" 4
.IX Item "kCoreEventClass"
Core Suite Event class.
.IP "kAEOpenApplication" 4
.IX Item "kAEOpenApplication"
Open application without documents.
.IP "kAEOpenDocuments" 4
.IX Item "kAEOpenDocuments"
Open documents.
.IP "kAEPrintDocuments" 4
.IX Item "kAEPrintDocuments"
Print documents.
.IP "kAEQuitApplication" 4
.IX Item "kAEQuitApplication"
Quit application.
.IP "kAEAnswer" 4
.IX Item "kAEAnswer"
Apple event answer event.
.IP "kAEApplicationDied" 4
.IX Item "kAEApplicationDied"
Launched application has ended.
.SS "Constants: Miscellaneous"
.IX Subsection "Constants: Miscellaneous"
.IP "kAENoReply" 4
.IX Item "kAENoReply"
.PD 0
.IP "kAEQueueReply" 4
.IX Item "kAEQueueReply"
.IP "kAEWaitReply" 4
.IX Item "kAEWaitReply"
.IP "kAENeverInteract" 4
.IX Item "kAENeverInteract"
.IP "kAECanInteract" 4
.IX Item "kAECanInteract"
.IP "kAEAlwaysInteract" 4
.IX Item "kAEAlwaysInteract"
.IP "kAECanSwitchLayer" 4
.IX Item "kAECanSwitchLayer"
.IP "kAEDontReconnect" 4
.IX Item "kAEDontReconnect"
.IP "kAEWantReceipt" 4
.IX Item "kAEWantReceipt"
.IP "kAEDontRecord" 4
.IX Item "kAEDontRecord"
.IP "kAEDontExecute" 4
.IX Item "kAEDontExecute"
.IP "kAEInteractWithSelf" 4
.IX Item "kAEInteractWithSelf"
.IP "kAEInteractWithLocal" 4
.IX Item "kAEInteractWithLocal"
.IP "kAEInteractWithAll" 4
.IX Item "kAEInteractWithAll"
.PD
Apple event sendMode flags.
.IP "kAENormalPriority" 4
.IX Item "kAENormalPriority"
.PD 0
.IP "kAEHighPriority" 4
.IX Item "kAEHighPriority"
.PD
Apple event priority values.
.IP "kAEStartRecording" 4
.IX Item "kAEStartRecording"
.PD 0
.IP "kAEStopRecording" 4
.IX Item "kAEStopRecording"
.IP "kAENotifyStartRecording" 4
.IX Item "kAENotifyStartRecording"
.IP "kAENotifyStopRecording" 4
.IX Item "kAENotifyStopRecording"
.IP "kAENotifyRecording" 4
.IX Item "kAENotifyRecording"
.PD
Recording events.
.IP "kAutoGenerateReturnID" 4
.IX Item "kAutoGenerateReturnID"
.PD 0
.IP "kAnyTransactionID" 4
.IX Item "kAnyTransactionID"
.IP "kAEDefaultTimeout" 4
.IX Item "kAEDefaultTimeout"
.IP "kNoTimeOut" 4
.IX Item "kNoTimeOut"
.PD
Special values for return \s-1ID,\s0 transaction \s-1ID,\s0 and timeout.
.IP "kAENoDispatch" 4
.IX Item "kAENoDispatch"
.PD 0
.IP "kAEUseStandardDispatch" 4
.IX Item "kAEUseStandardDispatch"
.IP "kAEDoNotIgnoreHandler" 4
.IX Item "kAEDoNotIgnoreHandler"
.IP "kAEIgnoreAppPhacHandler" 4
.IX Item "kAEIgnoreAppPhacHandler"
.IP "kAEIgnoreAppEventHandler" 4
.IX Item "kAEIgnoreAppEventHandler"
.IP "kAEIgnoreSysPhacHandler" 4
.IX Item "kAEIgnoreSysPhacHandler"
.IP "kAEIgnoreSysEventHandler" 4
.IX Item "kAEIgnoreSysEventHandler"
.IP "kAEIngoreBuiltInEventHandler" 4
.IX Item "kAEIngoreBuiltInEventHandler"
.IP "kAEDontDisposeOnResume" 4
.IX Item "kAEDontDisposeOnResume"
.PD
Options for \f(CW\*(C`AEResumeTheCurrentEvent()\*(C'\fR.
.SS "Variables"
.IX Subsection "Variables"
.ie n .IP "%AppleEvent" 4
.el .IP "\f(CW%AppleEvent\fR" 4
.IX Item "%AppleEvent"
An array of application-wide event handlers.
.Sp
.Vb 1
\&   $AppleEvent{"aevt", "odoc"} = \e&OpenDocument;
.Ve
.ie n .IP "%SysAppleEvent" 4
.el .IP "\f(CW%SysAppleEvent\fR" 4
.IX Item "%SysAppleEvent"
An arrary of system-wide event handlers.
.SS "AEDesc"
.IX Subsection "AEDesc"
AEDesc is a Perl package that encapsulates an Apple Event Descriptor.
It uses the \s-1OO\s0 methods of Perl5 to make building and parsing data structures
easier.
.IP "new \s-1TYPE, HANDLE\s0" 4
.IX Item "new TYPE, HANDLE"
.PD 0
.IP "new \s-1TYPE, DATA\s0" 4
.IX Item "new TYPE, DATA"
.IP "new \s-1TYPE\s0" 4
.IX Item "new TYPE"
.IP "new" 4
.IX Item "new"
.PD
Create a new Apple event descriptor.
Sets the type and data to \s-1TYPE \s0(default is 'null'), and \s-1HANDLE\s0 or \s-1DATA 
\&\s0(default is empty).
.Sp
.Vb 1
\&        $desc = new AEDesc("aevt", $event);
.Ve
.IP "type \s-1TYPE\s0" 4
.IX Item "type TYPE"
.PD 0
.IP "type" 4
.IX Item "type"
.PD
Return the type from the AEDesc structure.  
If \s-1TYPE\s0 is present, make it the new type.
.IP "data \s-1HANDLE\s0" 4
.IX Item "data HANDLE"
.PD 0
.IP "data" 4
.IX Item "data"
.PD
Return the data from the AEDesc structure. If \s-1HANDLE\s0 is present, make
it the new data.
.Sp
\&\fBWarning\fR: If using Mac \s-1OS X,\s0 you must dispose of the result on your own.
This is because in Mac \s-1OS,\s0 we returned the handle from the AEDesc itself,
but now we must return a copy.  So in Mac \s-1OS\s0 we could do:
.Sp
.Vb 1
\&        print $desc\->data\->get;
.Ve
.Sp
Now we must do:
.Sp
.Vb 3
\&        my $handle = $desc\->data;
\&        print $handle\->get;
\&        $handle\->dispose;
.Ve
.Sp
Normally, you don't want to call \f(CW\*(C`data\*(C'\fR directly anyway, and you would
use \f(CW\*(C`get\*(C'\fR instead.
.IP "get" 4
.IX Item "get"
Return the data of the AEDesc structure in a smartly unpacked way.
.IP "dispose" 4
.IX Item "dispose"
Dispose the AEDesc.
.SS "AEKeyDesc"
.IX Subsection "AEKeyDesc"
AEKeyDesc is a Perl package that encapsulates an Apple event keyword.
It uses the \s-1OO\s0 methods of Perl5 to make building and parsing data structures
easier.
.IP "new \s-1KEY, TYPE, HANDLE\s0" 4
.IX Item "new KEY, TYPE, HANDLE"
.PD 0
.IP "new \s-1KEY, TYPE, DATA\s0" 4
.IX Item "new KEY, TYPE, DATA"
.IP "new \s-1KEY, TYPE\s0" 4
.IX Item "new KEY, TYPE"
.IP "new \s-1KEY\s0" 4
.IX Item "new KEY"
.IP "new" 4
.IX Item "new"
.PD
Creates a new Apple event keyword descriptor.
Sets the keyword, type and data to \s-1KEY \s0(default is zero),
\&\s-1TYPE \s0(default is 'null'), and \s-1HANDLE\s0 or \s-1DATA \s0(default is empty).
.IP "key \s-1KEY\s0" 4
.IX Item "key KEY"
.PD 0
.IP "key" 4
.IX Item "key"
.PD
Return the keyword of the AEKeyDesc structure.
If \s-1KEY\s0 is present, make it the new keyword.
.IP "type \s-1TYPE\s0" 4
.IX Item "type TYPE"
.PD 0
.IP "type" 4
.IX Item "type"
.PD
Return the type from the AEKeyDesc structure.  If \s-1TYPE\s0 is present, make it the new type.
.IP "data \s-1HANDLE\s0" 4
.IX Item "data HANDLE"
.PD 0
.IP "data" 4
.IX Item "data"
.PD
Return the data from the AEKeyDesc structure. If \s-1HANDLE\s0 is present, make
it the new data.
.IP "get" 4
.IX Item "get"
Return the contents in a smartly unpacked way.
.IP "dispose" 4
.IX Item "dispose"
Dispose the underlying AEDesc.
.SS "Raw AppleEvent Interface"
.IX Subsection "Raw AppleEvent Interface"
.IP "AECreateDesc \s-1TYPE, DATA\s0" 4
.IX Item "AECreateDesc TYPE, DATA"
The AECreateDesc function creates a new descriptor record that incorporates the
specified data.
.IP "AECoerce \s-1TYPE, DATA, NEWTYPE\s0" 4
.IX Item "AECoerce TYPE, DATA, NEWTYPE"
.PD 0
.IP "AECoerceDesc \s-1DESC, NEWTYPE\s0" 4
.IX Item "AECoerceDesc DESC, NEWTYPE"
.PD
The AECoerceDesc function attempts to create a new descriptor record by coercing
the specified descriptor record. AECoerce attempts the same with a Perl data string.
.IP "AEDisposeDesc \s-1DESC\s0" 4
.IX Item "AEDisposeDesc DESC"
Deallocate the memory used by a descriptor record.
.Sp
.Vb 3
\&        if ( !AEDisposeDesc($desc) ) {
\&                # error occurred
\&        }
.Ve
.IP "AEDuplicateDesc \s-1DESC\s0" 4
.IX Item "AEDuplicateDesc DESC"
Creates a new descriptor record by copying the
descriptor record from the parameter \f(CW$DESC\fR.
.Sp
.Vb 4
\&        $newDesc = AEDuplicateDesc($desc);
\&        if ( defined $newDesc ) {
\&                # do something productive
\&        }
.Ve
.IP "AECreateList \s-1FACTOR, BOOL\s0" 4
.IX Item "AECreateList FACTOR, BOOL"
The AECreateList function creates an empty descriptor list (\s-1BOOL\s0 is 0),
or \s-1AE\s0 record (\s-1BOOL\s0 is nonzero). \s-1FACTOR\s0 contains the common prefix for each
descriptor or is empty.
.Sp
.Vb 4
\&        $list = AECreateList("", 0);
\&        if ( defined $list ) {
\&                # do something productive
\&        }
.Ve
.IP "AECountItems \s-1DESCLIST\s0" 4
.IX Item "AECountItems DESCLIST"
Count the number of descriptor records in any descriptor list. The result
is \f(CW\*(C`undef\*(C'\fR if the list is invalid.
.IP "AEPut \s-1DESCLIST, INDEX, TYPE, HANDLE\s0" 4
.IX Item "AEPut DESCLIST, INDEX, TYPE, HANDLE"
.PD 0
.IP "AEPutDesc \s-1DESCLIST, INDEX, DESC\s0" 4
.IX Item "AEPutDesc DESCLIST, INDEX, DESC"
.PD
Add a descriptor record to any descriptor list. AEPut will manufacture the 
record to add it to the list.
Return zero if an error was detected.
.IP "AEPutKey \s-1DESCLIST, KEY, TYPE, HANDLE\s0" 4
.IX Item "AEPutKey DESCLIST, KEY, TYPE, HANDLE"
.PD 0
.IP "AEPutKeyDesc \s-1DESCLIST, KEY, DESC\s0" 4
.IX Item "AEPutKeyDesc DESCLIST, KEY, DESC"
.PD
Add a descriptor record and a keyword to an \s-1AE\s0 record. AEPutKey will manufacture the 
record to add it to the \s-1AE\s0 record.
Return zero if an error was detected.
.IP "AEGetNthDesc \s-1DESCLIST, INDEX\s0 [, \s-1TYPE\s0]" 4
.IX Item "AEGetNthDesc DESCLIST, INDEX [, TYPE]"
The AEGetNthDesc function returns a specified descriptor record from a specified
descriptor list. The result is an AEDesc object and the keyword from a keyword
specified list.
.Sp
.Vb 4
\&        ($Desc, $Key) = AEGetNthDesc($DescList, $i);
\&        if ( defined $Desc ) {
\&                # do something productive
\&        }
.Ve
.IP "AEGetKeyDesc \s-1DESCLIST, KEY\s0 [, \s-1TYPE\s0]" 4
.IX Item "AEGetKeyDesc DESCLIST, KEY [, TYPE]"
The AEGetKeyDesc function returns a keyword-specified descriptor record from
a specified descriptor record.	The result is an AEDesc object.
.IP "AEDeleteItem \s-1DESCLIST, INDEX\s0" 4
.IX Item "AEDeleteItem DESCLIST, INDEX"
Delete a descriptor record from a descriptor list. All subsequent descriptor
records will then move up one place.
.IP "AEPutParam \s-1EVENT, KEY, TYPE, HANDLE\s0" 4
.IX Item "AEPutParam EVENT, KEY, TYPE, HANDLE"
.PD 0
.IP "AEPutParamDesc \s-1EVENT, KEY, DESC\s0" 4
.IX Item "AEPutParamDesc EVENT, KEY, DESC"
.PD
Add a descriptor record and a keyword to an Apple event as an Apple event
parameter. AEPutParam creates the descriptor record.
.IP "AEGetParamDesc \s-1EVENT, KEY\s0 [, \s-1TYPE\s0]" 4
.IX Item "AEGetParamDesc EVENT, KEY [, TYPE]"
The AEGetParamDesc function returns the descriptor
record for a specified Apple event parameter, which it attempts to coerce to the
descriptor type specified by \s-1TYPE \s0(default is no coercion).
.IP "AEDeleteParam \s-1EVENT, KEY\s0" 4
.IX Item "AEDeleteParam EVENT, KEY"
Delete an Apple event parameter.
Return zero if an error was detected.
.IP "AEGetAttributeDesc \s-1EVENT, KEY, TYPE\s0" 4
.IX Item "AEGetAttributeDesc EVENT, KEY, TYPE"
The AEGetAttributeDesc function returns the descriptor
record for the Apple event attribute with the specified keyword.
.IP "AEPutAttribute \s-1EVENT, KEY, TYPE, HANDLE\s0" 4
.IX Item "AEPutAttribute EVENT, KEY, TYPE, HANDLE"
.PD 0
.IP "AEPutAttributeDesc \s-1EVENT, KEY, DESC\s0" 4
.IX Item "AEPutAttributeDesc EVENT, KEY, DESC"
.PD
The AEPutAttributeDesc function takes a descriptor record and a keyword and adds
them to an Apple event as an attribute.
AEPutAttribute creates the record from \s-1TYPE\s0 and \s-1HANDLE. \s0
Return zero if an error was detected.
.IP "AECreateAppleEvent \s-1CLASS, EVENTID, DESC\s0 [, \s-1RETURNID\s0 [, \s-1TRANSACTIONID \s0] ]" 4
.IX Item "AECreateAppleEvent CLASS, EVENTID, DESC [, RETURNID [, TRANSACTIONID ] ]"
The AECreateAppleEvent function creates an Apple event and returns it.
\&\s-1TRANSACTIONID\s0 defaults to zero.
\&\s-1RETURNID\s0 defaults to kAutoGenerateReturnID.
.IP "AESend \s-1EVENT, SENDMODE\s0 [, \s-1SENDPRIORITY\s0 [, \s-1TIMEOUT \s0] ]" 4
.IX Item "AESend EVENT, SENDMODE [, SENDPRIORITY [, TIMEOUT ] ]"
Send the Apple Event \s-1EVENT. 
TIMEOUT\s0 defaults to kAEDefaultTimeout.
\&\s-1SENDPRIORITY\s0 defaults to kAENormalPriority.
Returns the reply if \s-1SENDMODE\s0 was kAEWaitReply.
.IP "AEResetTimer \s-1REPLY\s0" 4
.IX Item "AEResetTimer REPLY"
The Apple Event Manager for the server
application uses the default reply to send a Reset Timer event to the client
application; the Apple Event Manager for the client application's computer
intercepts this Apple event and resets the client application's timer for the
Apple event.
.IP "AESuspendTheCurrentEvent \s-1EVENT\s0" 4
.IX Item "AESuspendTheCurrentEvent EVENT"
After a server application makes a successful call to the
AESuspendTheCurrentEvent function, it is no longer required to return a result or
a reply for the Apple event that was being handled. The result is zero if no error
was detected.
.IP "AEResumeTheCurrentEvent \s-1EVENT\s0 [, \s-1FLAGS, REFCON\s0]" 4
.IX Item "AEResumeTheCurrentEvent EVENT [, FLAGS, REFCON]"
The Apple Event
Manager resumes handling the specified Apple event using the handler specified in
the \s-1FLAGS\s0 parameter, if any. If \s-1FLAGS\s0 and \s-1REFCON\s0 are missing, 
AEResumeTheCurrentEvent simply informs the Apple Event Manager that
the specified event has been handled.
.IP "AEGetTheCurrentEvent" 4
.IX Item "AEGetTheCurrentEvent"
Get the Apple event that is currently being handled.
.IP "AESetTheCurrentEvent \s-1EVENT\s0" 4
.IX Item "AESetTheCurrentEvent EVENT"
There is usually no reason for your application to use the AESetTheCurrentEvent
function.
.IP "AEGetInteractionAllowed" 4
.IX Item "AEGetInteractionAllowed"
The AEGetInteractionAllowed function returns a value
that indicates the user interaction preferences for responding to an Apple event.
The result is \f(CW\*(C`undef\*(C'\fR if an error was detected.
.IP "AESetInteractionAllowed \s-1LEVEL\s0" 4
.IX Item "AESetInteractionAllowed LEVEL"
The AESetInteractionAllowed function sets the user interaction level for a server
application's response to an Apple event. The result is zero if no error was detected.
.IP "AEInstallEventHandler \s-1CLASS, EVENTID, HANDLER, HANDLERREFCON\s0 [, \s-1SYSTEM\s0]" 4
.IX Item "AEInstallEventHandler CLASS, EVENTID, HANDLER, HANDLERREFCON [, SYSTEM]"
The AEInstallEventHandler function creates an entry in the Apple event dispatch
table. You must supply parameters that specify the event class, the event \s-1ID,\s0 the
address of the handler that handles Apple events of the specified event class and
event \s-1ID,\s0 and whether the handler is to be added to the system Apple event
dispatch table or your application's Apple event dispatch table. You can also
specify a reference constant that the Apple Event Manager passes to your handler
whenever your handler processes an Apple event.
.Sp
.Vb 3
\&        if (!AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, \*(AqOpenDocument\*(Aq, 0) ) {
\&                # an error occurred.
\&        }
.Ve
.Sp
A much more uniform (and Perl-ish) method is available using the hash arrays
\&\f(CW%AppleEvent\fR and \f(CW%SysAppleEvent\fR to bind handlers to event types.
.Sp
.Vb 3
\&        $AppleEvent{kCoreEventClass, kAEOpenDocuments} = \*(AqOpenDocument\*(Aq;
\&        ...
\&        delete $AppleEvent{kCoreEventClass, kAEOpenDocuments};
.Ve
.IP "AERemoveEventHandler \s-1CLASS, EVENTID\s0 [, \s-1SYSTEM\s0]" 4
.IX Item "AERemoveEventHandler CLASS, EVENTID [, SYSTEM]"
The AERemoveEventHandler function removes the Apple event dispatch table entry
you specify in the parameters \s-1CLASS, EVENTID,\s0 and \s-1SYSTEM. \s0
.IP "AEGetEventHandler \s-1CLASS, EVENTID\s0 [, \s-1SYSTEM\s0]" 4
.IX Item "AEGetEventHandler CLASS, EVENTID [, SYSTEM]"
The AEGetEventHandler function returns the handler and handlerrefcon for
the specified class and event.
.Sp
.Vb 1
\&        ($proc, $refcon) = AEGetEventHandler("aevt", "oapp");
.Ve
.IP "AEManagerInfo \s-1KEY\s0" 4
.IX Item "AEManagerInfo KEY"
Obtain information about the version of the Apple Event Manager currently
available or the number of processes that are currently recording Apple events. 
The result is \f(CW\*(C`undef\*(C'\fR if an error occurred.
.SS "AEGizmos Build/Print"
.IX Subsection "AEGizmos Build/Print"
The Apple Event Gizmos were developed by Jens Peter Alfke at Apple as a vastly
speeded up \s-1AE\s0 library. Consult the AEGizmo documentation for details of usage
of the library. The Build/Print facility uses a formatting convention similar
to scanf/printf to put things together.
.IP "AEBuild \s-1FORMAT, PARM, ...\s0" 4
.IX Item "AEBuild FORMAT, PARM, ..."
Build an AppleEvent descriptor using the format per the Gizmo documentation
and return it.
.IP "AEBuildParameters \s-1EVENT, FORMAT, PARM, ...\s0" 4
.IX Item "AEBuildParameters EVENT, FORMAT, PARM, ..."
Build parameters for an existing AppleEvent \s-1EVENT.\s0
.Sp
.Vb 3
\&        if (!AEBuildParameters($reply, $format, $parm1, $parm2) ) {
\&                # an error occurred
\&        }
.Ve
.IP "AEBuildAppleEvent \s-1CLASS, ID, ADDRESSTYPE, ADDRESS, RETURNID, TRANSACTIONID, FORMAT, PARMS, ...\s0" 4
.IX Item "AEBuildAppleEvent CLASS, ID, ADDRESSTYPE, ADDRESS, RETURNID, TRANSACTIONID, FORMAT, PARMS, ..."
Construct an AppleEvent from the format and parameters and return it.
.IP "AEPrint \s-1DESC\s0" 4
.IX Item "AEPrint DESC"
Return a string version of the descriptor record. The result is \f(CW\*(C`undef\*(C'\fR
if an error occurred.
.SS "AEGizmos Subdescriptors"
.IX Subsection "AEGizmos Subdescriptors"
The Apple Event Gizmos subdescriptor approach uses a dictionary method for
extracting and constructing descriptors.  Parsing an Apple Event using the
dictionary is very time efficient, and translating to and from the dictionary
tables is quick and efficient.
.IP "AEDescToSubDesc \s-1DESC\s0" 4
.IX Item "AEDescToSubDesc DESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Translate \s-1DESC\s0 to a subdescriptor (dictionary entry). 
Return the subdescriptor.
.IP "AEGetSubDescType \s-1SUBDESC\s0" 4
.IX Item "AEGetSubDescType SUBDESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Return the type of the subdescriptor.
.IP "AEGetSubDescBasicType \s-1SUBDESC\s0" 4
.IX Item "AEGetSubDescBasicType SUBDESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Return the basic type of the subdescriptor. Differs from AEGetSubDescType
in handling of coerced records.
.IP "AESubDescIsListOrRecord \s-1SUBDESC\s0" 4
.IX Item "AESubDescIsListOrRecord SUBDESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Return nonzero if the subdescriptor is a list or record.
.IP "AEGetSubDescData \s-1SUBDESC\s0" 4
.IX Item "AEGetSubDescData SUBDESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Returns the data of the subdescriptor.
.IP "AESubDescToDesc \s-1SUBDESC, DESIREDTYPE\s0" 4
.IX Item "AESubDescToDesc SUBDESC, DESIREDTYPE"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Translate the subdescriptor back to a descriptor of the desired type.
.IP "AECountSubDescItems \s-1SUBDESC\s0" 4
.IX Item "AECountSubDescItems SUBDESC"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Counts the number of subdescriptor items.
.IP "AEGetNthSubDesc \s-1SUBDESC,INDEX\s0" 4
.IX Item "AEGetNthSubDesc SUBDESC,INDEX"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Returns the item \s-1INDEX\s0 of the subdescriptor and its type if the subdescriptor
represented a record and not a list.
.IP "AEGetKeySubDesc \s-1SUBDESC,KW\s0" 4
.IX Item "AEGetKeySubDesc SUBDESC,KW"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Returns the keyword indexed item from the subdescriptor.
.SS "AEStream"
.IX Subsection "AEStream"
The Apple Event Gizmos streams approach uses a streaming model for building 
a sequence of descriptors.
.IP "new AEStream" 4
.IX Item "new AEStream"
.PD 0
.IP "AEStream::Open" 4
.IX Item "AEStream::Open"
.PD
Return a new AEStream.
.IP "new AEStream(\s-1CLASS, ID, ADDRESSTYPE, ADDRESS\s0 [, \s-1RETURNID\s0 [, \s-1TRANSACTIONID \s0] ])" 4
.IX Item "new AEStream(CLASS, ID, ADDRESSTYPE, ADDRESS [, RETURNID [, TRANSACTIONID ] ])"
.PD 0
.IP "AEStream::CreateEvent \s-1CLASS, ID, ADDRESSTYPE, ADDRESS, RETURNID, TRANSACTIONID\s0" 4
.IX Item "AEStream::CreateEvent CLASS, ID, ADDRESSTYPE, ADDRESS, RETURNID, TRANSACTIONID"
.PD
Create an AEStream attached to a new AppleEvent.
.IP "new AEStream(\s-1EVENT\s0)" 4
.IX Item "new AEStream(EVENT)"
.PD 0
.IP "AEStream::OpenEvent \s-1EVENT\s0" 4
.IX Item "AEStream::OpenEvent EVENT"
.PD
Opens the stream on the \f(CW$EVENT\fR.
Return \f(CW\*(C`undef\*(C'\fR if an error was detected.
.IP "Close" 4
.IX Item "Close"
Return the descriptor corresponding to the stream, and close it out.
.Sp
.Vb 1
\&        $stream\->Close;
.Ve
.IP "Abort \s-1STREAM\s0" 4
.IX Item "Abort STREAM"
Abort the streaming process, and close it out.
.Sp
.Vb 1
\&        $stream\->Abort;
.Ve
.IP "OpenDesc \s-1TYPE\s0" 4
.IX Item "OpenDesc TYPE"
Start building a descriptor of the given type.
Return zero if an error was detected.
.Sp
.Vb 8
\&        if ( $stream\->OpenDesc($type) ) {
\&                # Long messy calculation that demonstrates the usefullness of this code
\&                if ( $stream\->WriteData($calculatedData) 
\&                 &&  $stream\->CloseDesc()
\&                ){
\&                        # then, my work here is done
\&                }
\&        }
.Ve
.IP "WriteData \s-1DATA\s0" 4
.IX Item "WriteData DATA"
Add data to the descriptor.
.IP "CloseDesc" 4
.IX Item "CloseDesc"
Finish up the descriptor.
.IP "WriteDesc \s-1TYPE, DATA\s0" 4
.IX Item "WriteDesc TYPE, DATA"
Add the arbitrary data with the given type as a descriptor to the stream.
.IP "WriteAEDesc \s-1STREAM, AEDESC\s0" 4
.IX Item "WriteAEDesc STREAM, AEDESC"
Add an Apple Event descriptor to the stream.
.IP "OpenList" 4
.IX Item "OpenList"
Start building a list of AppleEvent descriptors in the stream.
.IP "CloseList \s-1STREAM\s0" 4
.IX Item "CloseList STREAM"
Return zero if an error was detected.
.Sp
.Vb 6
\&        if ( $stream\->OpenList() ) {
\&                for $desc (@descList) {
\&                        croak unless $stream\->WriteAEDesc($desc);
\&                }
\&                die unless $stream\->CloseList();
\&        }
.Ve
.IP "OpenRecord [\s-1TYPE\s0]" 4
.IX Item "OpenRecord [TYPE]"
Start the process of building a record, to be coerced to the given type.
.IP "SetRecordType \s-1TYPE\s0" 4
.IX Item "SetRecordType TYPE"
Change the record type.
.IP "CloseRecord \s-1STREAM\s0" 4
.IX Item "CloseRecord STREAM"
Close the record currently under construction.
.Sp
.Vb 7
\&        if ( $stream\->OpenRecord(typeAErecord) ) {
\&                for $kdesc (@descList) {
\&                        die unless $stream\->WriteKey($kdesc\->key) and 
\&                                        $stream\->WriteAEDesc($kdesc\->desc);
\&                }
\&                die unless $stream\->CloseRecord();
\&        }
.Ve
.IP "WriteKeyDesc \s-1KEY, TYPE, DATA\s0" 4
.IX Item "WriteKeyDesc KEY, TYPE, DATA"
Add the keyword descriptor to the stream.
.IP "OpenKeyDesc \s-1KEY, TYPE\s0" 4
.IX Item "OpenKeyDesc KEY, TYPE"
Open a descriptor with the given type and key.
Use \fICloseDesc()\fR to close it.
.IP "WriteKey  \s-1KEY\s0" 4
.IX Item "WriteKey KEY"
Add the keyword to the immediately following descriptor.
Return zero if an error was detected.
.IP "OptionalParam \s-1KEY\s0" 4
.IX Item "OptionalParam KEY"
Adds the keyword to the list of optional attributes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Matthias Ulrich Neeracher <neeracher@mac.com>,
documentation by Bob Dalgleish <bob.dalgleish@sasknet.sk.ca>.
Currently maintained by Chris Nandor <pudge@pobox.com>.
