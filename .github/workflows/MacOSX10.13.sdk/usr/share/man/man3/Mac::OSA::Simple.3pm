.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simple 3"
.TH Simple 3 "2005-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mac::OSA::Simple \- Simple access to Mac::OSA
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&    #!perl \-wl
\&    use Mac::OSA::Simple;
\&    osa_script(\*(AqLAND\*(Aq, <<\*(AqEOS\*(Aq);
\&      dialog.getInt ("Duration?",@examples.duration);
\&      dialog.getInt ("Amplitude?",@examples.amplitude);
\&      dialog.getInt ("Frequency?",@examples.frequency);
\&      speaker.sound (examples.duration, examples.amplitude,
\&          examples.frequency)
\&    EOS
\&
\&    print frontier(\*(Aqclock.now()\*(Aq);
\&
\&    applescript(\*(Aqbeep 3\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
You can access scripting components via the tied hash
\&\f(CW%ScriptComponents\fR which is automatically exported.  Components are
only opened if they have not been already, and are closed when the
program exits.  It is normally not necessary to use this hash, as it is
accessed internally when needed.
.PP
Also usually not necessary, but possibly useful, are all the functions
and constants from Mac::OSA, available with the \s-1EXPORT_TAG \s0\*(L"all\*(R".
.PP
\&\fB\s-1NOTE\s0\fR: Examples below show use of $^E.  On Mac \s-1OS,\s0 this will return the
signed Mac \s-1OS\s0 error number in numeric context, and the Mac \s-1OS\s0 error message
in string context.  But on Mac \s-1OS X,\s0 $^E support is unimplemented.  $! and $^E
will both return the \fIunsigned\fR error number.  You can get the correct error
number by adding 0 (such as \f(CW\*(C`$! + 0\*(C'\fR), and you can use Mac::Errors to get
the error text (this will also work under Mac \s-1OS\s0):
.PP
.Vb 2
\&        use Mac::Errors \*(Aq$MacError\*(Aq;
\&        my $res = FSpOpenResFile($file, 0) or die $MacError;
.Ve
.PP
See Mac::Errors on the \s-1CPAN\s0 for more information.
.SS "Functions"
.IX Subsection "Functions"
The following functions are automatically exported.
.IP "osa_script(\s-1SCRIPTCOMPONENT, SCRIPTTEXT\s0)" 4
.IX Item "osa_script(SCRIPTCOMPONENT, SCRIPTTEXT)"
Compiles and executes \s-1SCRIPTTEXT,\s0 using four-char \s-1SCRIPTCOMPONENT.\s0
Component is opened and closed behind the scenes, and \s-1SCRIPTTEXT\s0
is compiled, executed, and disposed of behind the scenes.  If
the script returns data, the function returns the data, else it
returns 1 or undef on failure.
.IP "applescript(\s-1SCRIPTTEXT\s0)" 4
.IX Item "applescript(SCRIPTTEXT)"
.PD 0
.IP "frontier(\s-1SCRIPTTEXT\s0)" 4
.IX Item "frontier(SCRIPTTEXT)"
.PD
Same thing as \f(CW\*(C`osa_script\*(C'\fR with \s-1SCRIPTCOMPONENT\s0 already set
('ascr' for AppleScript, '\s-1LAND\s0' for Frontier).
.IP "compile_osa_script(\s-1SCRIPTCOMPONENT, SCRIPTTEXT\s0)" 4
.IX Item "compile_osa_script(SCRIPTCOMPONENT, SCRIPTTEXT)"
Compiles script as \f(CW\*(C`osa_script\*(C'\fR above, but does not execute it.
Returns Mac::OSA::Simple object.  See \*(L"Methods\*(R" for more information.
.IP "compile_applescript(\s-1SCRIPTTEXT\s0)" 4
.IX Item "compile_applescript(SCRIPTTEXT)"
.PD 0
.IP "compile_frontier(\s-1SCRIPTTEXT\s0)" 4
.IX Item "compile_frontier(SCRIPTTEXT)"
.PD
Same thing as \f(CW\*(C`compile_osa_script\*(C'\fR with \s-1SCRIPTCOMPONENT\s0 already set.
.IP "load_osa_script(\s-1HANDLE\s0)" 4
.IX Item "load_osa_script(HANDLE)"
.PD 0
.IP "load_osa_script(\s-1FILE\s0 [, \s-1RESOURCEID\s0])" 4
.IX Item "load_osa_script(FILE [, RESOURCEID])"
.PD
In the first form, load compiled \s-1OSA\s0 script using data in Handle
(same data as returned by \f(CW\*(C`compiled\*(C'\fR method; see Mac::Memory).
In the second form, gets
script from \s-1FILE\s0 using \s-1RESOURCEID \s0(which is 128 by default).  Returns
Mac::OSA::Simple object.
.Sp
\&\fB\s-1NOTE\s0\fR: Because of a change in the parameters for this function,
a \s-1RESOURCEID\s0 value of 1 will not be recognized as a resource \s-1ID
\&\s0(the old parameter list had a value of 1 mean \*(L"load from file\*(R").
If you need to use a resource \s-1ID\s0 of 1, pass it in as both the
second and third parameter.  Sorry.  Why would you use 1 for
a resource \s-1ID,\s0 anyway??
.Sp
Example:
.Sp
.Vb 8
\&    use Mac::OSA::Simple qw(:all);
\&    use Mac::Resources;
\&    $res = FSpOpenResFile($file, 0) or die $^E;
\&    $scpt = Get1Resource(kOSAScriptResourceType, 128)
\&        or die $^E;
\&    $osa = load_osa_script($scpt);
\&    $osa\->execute;
\&    CloseResFile($res);
.Ve
.Sp
Same thing:
.Sp
.Vb 3
\&    use Mac::OSA::Simple;
\&    $osa = load_osa_script($file);
\&    $osa\->execute;
.Ve
.Sp
Another example:
.Sp
.Vb 3
\&    use Mac::OSA::Simple;
\&    $osa1 = compile_applescript(\*(Aqreturn "foo"\*(Aq);
\&    print $osa1\->execute;
\&
\&    # make copy of script in $osa1 and execute it
\&    $osa2 = load_osa_script($osa1\->compiled);
\&    print $osa2\->execute;
.Ve
.Sp
See \*(L"Methods\*(R" for more information.
.SS "Methods"
.IX Subsection "Methods"
This section describes methods for use on objects returned by
\&\f(CW\*(C`compile_osa_script\*(C'\fR and its related functions and \f(CW\*(C`load_osa_script\*(C'\fR.
.IP "compiled" 4
.IX Item "compiled"
Returns a Handle containing the raw compiled form of the script
(see Mac::Memory).
.IP "dispose" 4
.IX Item "dispose"
Disposes of \s-1OSA\s0 script.  Done automatically if not called explicitly.
.IP "execute" 4
.IX Item "execute"
Executes script.  Can be executed more than once.
.IP "call(\s-1CLASS, EVENT, ARGS, MODE\s0)" 4
.IX Item "call(CLASS, EVENT, ARGS, MODE)"
Calls a handler in the script, identified by \s-1CLASS\s0 and \s-1EVENT\s0 IDs.
Can be executed more than once.
.Sp
\&\s-1ARGS\s0 can be either a scalar or an arrayref.  \s-1MODE\s0 can be any combination
of modes from Mac::OSA listed under the \*(L"Mode flags\*(R" constants.
.Sp
Here is an example script:
.Sp
.Vb 5
\&        on \exC7event abcd1234E\exC8 (filename)
\&            tell app "Finder"
\&               return [URL of file filename, creator type of file filename]
\&            end
\&        end
.Ve
.Sp
\&\*(L"abcd\*(R" is the \s-1CLASS ID,\s0 and \*(L"1234\*(R" is the \s-1EVENT ID. \s0 They can be anything, as
long as they don't conflict with something else.  The characters \exC7 and \exC8
can be literal if in the Mac Roman charset, otherwise just use the values like
above.
.Sp
Parameters are passed to handlers as named values, like \*(L"(filename)\*(R".  Multiple
parameters can be passed as an arrayref in \s-1ARGS,\s0 and a list of values is returned:
.Sp
.Vb 2
\&        my $script = load_osa_script($path_to_script);
\&        my($url, $creator) = $script\->call(qw[abcd 1234], "my file");
.Ve
.Sp
You must pass in the same number of variables in \s-1ARGS\s0 that are expected by the
handler.
.IP "save(\s-1FILE\s0 [, \s-1ID\s0 [, \s-1NAME\s0]])" 4
.IX Item "save(FILE [, ID [, NAME]])"
Saves script in \s-1FILE\s0 with \s-1ID\s0 and \s-1NAME.  ID\s0 defaults to 128, \s-1NAME\s0
defaults to \*(L"MacPerl Script\*(R".  \s-1DANGEROUS\s0!  Will overwrite
existing resource or file!
.Sp
Saves to the data fork instead on Mac \s-1OS X,\s0 unless an \s-1ID\s0 is provided.
.Sp
The context used to load a script from disk (resource fork vs. data fork,
resource file vs. data file) will be used to save the script back, if
applicable, so the file's format will be preserved.
.IP "source" 4
.IX Item "source"
Returns text of script source, if available.
.SS "Script Context"
.IX Subsection "Script Context"
Scripts compiled by this module now compile scripts as
\&\fIscript contexts\fR, which, in part, means they can maintain state
information.  For example:
.PP
.Vb 6
\&        use Mac::OSA::Simple;
\&        my $script = compile_applescript(<<\*(AqSCRIPT\*(Aq) or die $^E;
\&        property foo: 20
\&        set foo to foo + 1
\&        SCRIPT
\&        print $script\->execute, "\en" for 0..2;
.Ve
.PP
Returns:
	21
	22
	23
.PP
Whereas in previous versions of this module, it would have returned:
	21
	21
	21
.PP
For a script that on disk, to maintain state information
in the saved version, remember to call \f(CW\*(C`$script\-\*(C'\fRsave(\s-1LIST\s0)>.
.SH "TODO"
.IX Header "TODO"
Work on error handling.  We don't want to die when a toolbox function
fails.  We'd rather return undef and have the user check $^E.
.PP
Should \f(CW\*(C`frontier\*(C'\fR and/or \f(CW\*(C`osa_script(\*(AqLAND\*(Aq, $script)\*(C'\fR launch
Frontier if it is not running?
.PP
Add \f(CW\*(C`run_osa_script\*(C'\fR, which could take script data in a Handle or
a path to a script (as with \f(CW\*(C`load_osa_script\*(C'\fR.
.PP
Should \f(CW\*(C`save\*(C'\fR have optional parameter for overwriting resource?
.PP
Should \f(CW\*(C`run_osa_script\*(C'\fR and \f(CW\*(C`execute\*(C'\fR take arguments?  If so, how?
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Nandor <pudge@pobox.com>, http://pudge.net/
.PP
Copyright (c) 1998\-2003 Chris Nandor.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mac::OSA, Mac::AppleEvents, Mac::AppleEvents::Simple, macperlcat.
