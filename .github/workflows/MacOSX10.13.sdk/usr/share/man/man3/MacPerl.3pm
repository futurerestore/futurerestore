.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MacPerl 3"
.TH MacPerl 3 "2009-09-07" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MacPerl \- Built\-in Macintosh specific routines.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
\&
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
\&    MacPerl::GetFileInfo(yin);
\&
\&    MacPerl::Quit(kMacPerlAlwaysQuit);
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "MacPerl::Answer(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Answer(PROMPT)"
.PD 0
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2)"
.IP "MacPerl::Answer(\s-1PROMPT,BUTTON1,BUTTON2,BUTTON3\s0)" 8
.IX Item "MacPerl::Answer(PROMPT,BUTTON1,BUTTON2,BUTTON3)"
.PD
Presents to the user a dialog with 1, 2, or 3 buttons.
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::Answer("Nunc et in hora mortis nostrae", "Amen");
.Ve
.Sp
always returns 0.
.Sp
.Vb 1
\&    MacPerl::Answer("I refuse");
.Ve
.Sp
is equivalent to \f(CW\*(C`MacPerl\*(AqAnswer("I refuse", "OK");\*(C'\fR
.Sp
.Vb 1
\&    MacPerl::Answer("Delete hard disk ?", "OK", "Cancel");
.Ve
.Sp
returns 1 for \s-1OK, 0\s0 for Cancel
.Sp
.Vb 1
\&    MacPerl::Answer("Overwrite existig file", "Overwrite", "Skip", "Cancel");
.Ve
.Sp
returns 2 for Overwrite, 1 for Skip, 0 for Cancel
.IP "MacPerl::Ask(\s-1PROMPT, DEFAULT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT, DEFAULT)"
.PD 0
.IP "MacPerl::Ask(\s-1PROMPT\s0)" 8
.IX Item "MacPerl::Ask(PROMPT)"
.PD
Asks the user for a string. A default value may be given. Returns
undef if the dialog is cancelled.
.Sp
Example:
.Sp
.Vb 2
\&    $phone = MacPerl::Ask("Enter your phone number:");
\&    $name  = MacPerl::Ask("Enter your first name", "Bruce");
.Ve
.Sp
Useful for Australian database applications
.IP "MacPerl::Pick(\s-1PROMPT, VALUES\s0)" 8
.IX Item "MacPerl::Pick(PROMPT, VALUES)"
Asks the user to pick a choice from a list. \s-1VALUES\s0 is a list of choices. 
Returns undef if the dialog is cancelled.
.Sp
Examples:
.Sp
.Vb 1
\&    $color = MacPerl::Pick("What\*(Aqs your favorite color baby ?", "Red", "Green", "Gold");
.Ve
.IP "MacPerl::SetFileInfo(\s-1CREATOR,TYPE,FILE...\s0)" 8
.IX Item "MacPerl::SetFileInfo(CREATOR,TYPE,FILE...)"
Changes the file types and creators of the file(s).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::SetFileInfo("MPS ", "TEXT", yin, yang);
.Ve
.Sp
Turn yin and yang into \s-1MPW\s0 text files
.IP "MacPerl::GetFileInfo(\s-1FILE\s0)" 8
.IX Item "MacPerl::GetFileInfo(FILE)"
In scalar context, returns the file type. In array context, returns (creator,type).
.Sp
Examples:
.Sp
.Vb 1
\&    MacPerl::GetFileInfo(yin);
.Ve
.Sp
Returns \*(L"\s-1TEXT\*(R"\s0 or (\*(L"\s-1MPS \*(R", \*(L"TEXT\*(R"\s0).
.IP "MacPerl::DoAppleScript(\s-1SCRIPT\s0)" 8
.IX Item "MacPerl::DoAppleScript(SCRIPT)"
Execute an AppleScript script.  Returns the text of the script result.
Script error strings are returned in \f(CW$@\fR.
.Sp
Example:
.Sp
.Vb 7
\&        my $text = MacPerl::DoAppleScript(<<END_SCRIPT) or die $@;
\&        tell application "BBEdit"
\&                make new Window
\&                copy "Inserting text the hard way." to character 1 of front Window
\&                get (characters 1 through 9 of front Window) as text
\&        end tell
\&        END_SCRIPT
.Ve
.Sp
\&\fBNote\fR: calling DoAppleScript to tell MacPerl to do something via
AppleScript may yield unpredictable results, especially when waiting
on MacPerl to reply, such as when stringing multiple events together,
or expecting data to be returned.  Try wrapping the \*(L"tell\*(R" block in
\&\*(L"ignoring application responses\*(R" / \*(L"end ignoring\*(R" if necessary.
.IP "MacPerl::Reply(\s-1ANSWER\s0)" 8
.IX Item "MacPerl::Reply(ANSWER)"
Reply to current DoScript request. Useful if you are calling Perl 
scripts from other applications.
.IP "MacPerl::Quit(\s-1LEVEL\s0)" 8
.IX Item "MacPerl::Quit(LEVEL)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
If \s-1LEVEL\s0 is 0, don't quit after ending the script. If 1, quit if 
running under a runtime version, if 2, always quit. If \s-1LEVEL\s0 is 3,
quit if this was the first script to be run since starting MacPerl.
.IP "MacPerl::LoadExternals(\s-1LIBFILE\s0)" 8
.IX Item "MacPerl::LoadExternals(LIBFILE)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
Load \s-1XCMD\s0 and \s-1XFCN\s0 extensions contained in file \s-1LIBFILE,\s0 which is searched
along the same path as it would be for a require. The extensions are made
accessible in the current package, unless they containing an explicit package
name.
.IP "MacPerl::FAccess(\s-1FILE, CMD, ARGS\s0)" 8
.IX Item "MacPerl::FAccess(FILE, CMD, ARGS)"
\&\fBMac \s-1OS\s0 only.\fR
.Sp
When called from the tool, manipulate various information of files. To 
get the command constants, it's convenient to require \*(L"FAccess.ph\*(R".
.RS 8
.ie n .IP "$TAB = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.el .IP "\f(CW$TAB\fR = MacPerl::FAccess(\s-1FILE, F_GTABINFO\s0)" 8
.IX Item "$TAB = MacPerl::FAccess(FILE, F_GTABINFO)"
.PD 0
.IP "MacPerl::FAccess(\s-1FILE, F_STABINFO, TAB\s0)" 8
.IX Item "MacPerl::FAccess(FILE, F_STABINFO, TAB)"
.PD
Manipulate tabulator setting (in spaces per tab).
.ie n .IP "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "($FONTNAME, \f(CW$FONTSIZE\fR) = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "($FONTNAME, $FONTSIZE) = MacPerl::FAccess(FILE, F_GFONTINFO)"
.PD 0
.ie n .IP "$FONTNUM = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.el .IP "\f(CW$FONTNUM\fR = MacPerl::FAccess(\s-1FILE, F_GFONTINFO\s0)" 8
.IX Item "$FONTNUM = MacPerl::FAccess(FILE, F_GFONTINFO)"
.IP "MacPerl::FAccess(\s-1FILE, F_SFONTINFO, FONT\s0 [, \s-1SIZE\s0])" 8
.IX Item "MacPerl::FAccess(FILE, F_SFONTINFO, FONT [, SIZE])"
.PD
Manipulate font and size information. Both font names and font numbers
are accepted for F_SFONTINFO; F_GFONTINFO returns a font name in an
array context, a font number in a scalar context.
.ie n .IP "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "($STARTSEL, \f(CW$ENDSEL\fR, \f(CW$DISPLAYTOP\fR) = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "($STARTSEL, $ENDSEL, $DISPLAYTOP) = MacPerl::FAccess(FILE, F_GSELINFO)"
.PD 0
.ie n .IP "$STARTSEL = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.el .IP "\f(CW$STARTSEL\fR = MacPerl::FAccess(\s-1FILE, F_GSELINFO\s0)" 8
.IX Item "$STARTSEL = MacPerl::FAccess(FILE, F_GSELINFO)"
.ie n .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, $STARTSEL, $ENDSEL\s0 [, $DISPLAYTOP])" 8
.el .IP "MacPerl::FAccess(\s-1FILE, F_SSELINFO, \f(CW$STARTSEL\fR, \f(CW$ENDSEL\fR\s0 [, \f(CW$DISPLAYTOP\fR])" 8
.IX Item "MacPerl::FAccess(FILE, F_SSELINFO, $STARTSEL, $ENDSEL [, $DISPLAYTOP])"
.PD
Manipulate the \s-1MPW\s0 selection of a file.
.ie n .IP "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item $TOP = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.el .IP "($LEFT, \f(CW$TOP\fR, \f(CW$RIGHT\fR, \f(CW$BOTTOM\fR) = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item \f(CW$TOP\fR = MacPerl::FAccess(\s-1FILE, F_GWININFO\s0) =item MacPerl::FAccess(\s-1FILE, F_SWININFO, LEFT, TOP\s0 [, \s-1RIGHT, BOTTOM\s0])" 8
.IX Item "($LEFT, $TOP, $RIGHT, $BOTTOM) = MacPerl::FAccess(FILE, F_GWININFO) =item $TOP = MacPerl::FAccess(FILE, F_GWININFO) =item MacPerl::FAccess(FILE, F_SWININFO, LEFT, TOP [, RIGHT, BOTTOM])"
Manipulate the window position.
.RE
.RS 8
.RE
.IP "MacPerl::MakeFSSpec(\s-1PATH\s0)" 8
.IX Item "MacPerl::MakeFSSpec(PATH)"
This command encodes a path name into an encoding (volume #, directory #,
File name) which is guaranteed to be unique for every file. Don't store
this encoding between runs of MacPerl!
.IP "MacPerl::MakePath(\s-1FSSPEC\s0)" 8
.IX Item "MacPerl::MakePath(FSSPEC)"
The inverse of \fIMacPerl::MakeFSSpec()\fR: turn an encoding into a path name.
.IP "\fIMacPerl::Volumes()\fR" 8
.IX Item "MacPerl::Volumes()"
In scalar context, return the \s-1FSSPEC\s0 of the startup volume. In list context, 
return FSSPECs of all volumes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
macperl
