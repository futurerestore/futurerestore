// RTTI support for -*- C++ -*-
// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
// 2003, 2004, 2005, 2006, 2007
// Free Software Foundation
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.

// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.

/** @file typeinfo
 *  This is a Standard C++ Library header.
 */

#ifndef _TYPEINFO
#define _TYPEINFO

#include <exception>

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
} // namespace __cxxabiv1

#ifndef __GXX_MERGED_TYPEINFO_NAMES
  #if !__GXX_WEAK__
    // If weak symbols are not supported, typeinfo names are not merged.
    #define __GXX_MERGED_TYPEINFO_NAMES 0
  #else
    // On platforms that support weak symbols, typeinfo names are merged.
    #define __GXX_MERGED_TYPEINFO_NAMES 1
  #endif
#endif

#if defined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)
#define __GXX_NONUNIQUE_RTTI_BIT (1ULL << 63)
#endif

namespace std 
{
  /**
   *  @brief  Part of RTTI.
   *
   *  The @c type_info class describes type information generated by
   *  an implementation.
  */
  class type_info 
  {
  public:
    /** Destructor first. Being the first non-inline virtual function, this
     *  controls in which translation unit the vtable is emitted. The
     *  compiler makes use of that information to know where to emit
     *  the runtime-mandated type_info structures in the new-abi.  */
    virtual ~type_info();

    /** Returns an @e implementation-defined byte string; this is not
     *  portable between compilers!  */
    const char* name() const
#ifndef __GXX_NONUNIQUE_RTTI_BIT
    { return __name; }
#else
    { return reinterpret_cast<const char*>(__name & ~__GXX_NONUNIQUE_RTTI_BIT); }
#endif

#if !__GXX_MERGED_TYPEINFO_NAMES
    bool before(const type_info& __arg) const;

    // In old abi, or when weak symbols are not supported, there can
    // be multiple instances of a type_info object for one
    // type. Uniqueness must use the _name value, not object address.
    bool operator==(const type_info& __arg) const;
#else
    /** Returns true if @c *this precedes @c __arg in the implementation's
     *  collation order.  */
    // In new abi we can rely on type_info's NTBS being unique,
    // and therefore address comparisons are sufficient.
    bool before(const type_info& __arg) const
#ifndef __GXX_NONUNIQUE_RTTI_BIT
    { return __name < __arg.__name; }
#else
    { if (!((__name & __arg.__name) & __GXX_NONUNIQUE_RTTI_BIT))
        return __name < __arg.__name;
      return __compare_nonunique_names(__arg) < 0; }
#endif

    bool operator==(const type_info& __arg) const
#ifndef __GXX_NONUNIQUE_RTTI_BIT
    { return __name == __arg.__name; }
#else
    { if (__name == __arg.__name) return true;
      if (!((__name & __arg.__name) & __GXX_NONUNIQUE_RTTI_BIT))
        return false;
      return __compare_nonunique_names(__arg) == 0; }
#endif
#endif
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
#if 0    
   // APPLE LOCAL begin
   // For ABI stability these virtuals must be ordered: __is_pointer_p, __is_function_p, __do_catch, __do_upcast

   // Return true if this is a pointer type of some kind
    virtual bool __is_pointer_p() const;

    // Return true if this is a function type
    virtual bool __is_function_p() const;

    // Try and catch a thrown type. Store an adjusted pointer to the
    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
    // type, then THR_OBJ is the pointer itself. OUTER indicates the
    // number of outer pointers, and whether they were const
    // qualified.
    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
			    unsigned __outer) const;

    // Internally used during catch matching
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
			     void **__obj_ptr) const;

   // APPLE LOCAL end
#endif
  protected:
#ifndef __GXX_NONUNIQUE_RTTI_BIT
    const char *__name;
#else
    unsigned long __name;
#endif
    
    explicit type_info(const char *__n): 
#ifndef __GXX_NONUNIQUE_RTTI_BIT
    __name(__n) { }
#else
    __name(reinterpret_cast<unsigned long>(__n)) { }
#endif
    
  private:
#ifdef __GXX_NONUNIQUE_RTTI_BIT
  private:
    int __compare_nonunique_names(const type_info &__arg) const
    { return __builtin_strcmp(__name_for_load(), __arg.__name_for_load()); }

    const char *__name_for_load() const
    { unsigned long __data = __name;
#if 1 // <rdar://problem/13226050>
      __data &= ~__GXX_NONUNIQUE_RTTI_BIT;
#endif
      return reinterpret_cast<const char*>(__data); }
#endif

    /// Assigning type_info is not supported.
    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };

  /**
   *  @brief  Thrown during incorrect typecasting.
   *
   *  If you attempt an invalid @c dynamic_cast expression, an instance of
   *  this class (or something derived from this class) is thrown.  */
  class bad_cast : public exception 
  {
  public:
    bad_cast() throw() { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_cast() throw();

#if __TARGETING_4_0_DYLIB
	// bad_cast::what() not exported from libstdc++.6.0.4 dylib
#else
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
#endif
  };
  
  /** If you use a NULL pointer in a @c typeid expression, this is thrown.  */
  class bad_typeid : public exception 
  {
  public:
    bad_typeid () throw() { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_typeid() throw();

#if __TARGETING_4_0_DYLIB
	// bad_typeid::what() not exported from libstdc++.6.0.4 dylib
#else
    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
#endif
  };
} // namespace std

#pragma GCC visibility pop

} // extern "C++"
#endif
